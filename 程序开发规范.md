# SpringBoot 应用模板 - 程序开发规范

> 基于 Spring Boot 3.5.6 + MyBatis-Plus 3.5.9 + Spring Security 6.x 的企业级应用开发规范（完整版）

---

## 📋 文档概述

本文档是 SpringBoot 应用模板的开发规范指南，定义了基于此模板进行项目开发的标准流程、代码规范、最佳实践和使用方法。

**当前版本**: v3.0.0 - 涵盖阶段一至五（基础架构、数据访问层、安全与认证、日志与异常、文档与业务）
**适用范围**: 所有基于此模板的 Spring Boot 项目开发
**维护责任**: 项目架构师和技术负责人
**更新频率**: 每个阶段完成后更新
**最后更新**: 2025年10月23日

---

## 🏗️ 项目架构规范

### 分层架构标准

项目采用经典的分层架构模式，各层职责明确：

```
┌─────────────────────────────────────┐
│        Controller Layer            │  ← REST API 接口层
│        (@RestController)           │
├─────────────────────────────────────┤
│        Service Layer               │  ← 业务逻辑层
│        (@Service)                  │
├─────────────────────────────────────┤
│        Mapper Layer                │  ← 数据访问层
│        (@Mapper)                   │
├─────────────────────────────────────┤
│        Entity Layer                │  ← 实体模型层
│        (BaseEntity)                │
├─────────────────────────────────────┤
│        Common Layer                │  ← 通用组件层
│        (Utils, Enums, Config)      │
└─────────────────────────────────────┘
```

### 包结构规范

```
src/main/java/com/dawnmoon/springboot_app_template/
├── SpringbootAppTemplateApplication.java    # 主启动类
├── controller/                              # 控制器层
│   ├── AuthController.java                 # 认证控制器
│   └── UserController.java                 # 用户管理控制器 ✨ 新增
├── service/                                # 服务层
│   ├── AuthService.java                   # 认证服务接口
│   ├── UserService.java                   # 用户服务接口
│   └── serviceImpl/                       # 服务实现
│       ├── AuthServiceImpl.java           # 认证服务实现
│       └── UserServiceImpl.java           # 用户服务实现
├── mapper/                                 # 数据访问层
│   ├── UserMapper.java                    # 用户Mapper接口
│   ├── RoleMapper.java                    # 角色Mapper接口
│   └── UserRoleMapper.java                # 用户角色关联Mapper
├── model/                                  # 模型层
│   ├── entity/                            # 实体类
│   │   ├── BaseEntity.java               # 基础实体类
│   │   ├── User.java                     # 用户实体
│   │   ├── Role.java                     # 角色实体
│   │   └── UserRole.java                 # 用户角色关联实体
│   ├── request/                          # 请求参数对象
│   │   ├── AuthRequests.java            # 认证请求
│   │   └── UserRequests.java            # 用户请求 ✨ 新增
│   └── response/                         # 响应对象
│       ├── PageResponse.java            # 分页响应
│       └── UserResponse.java            # 用户响应 ✨ 新增
├── common/                                 # 通用组件
│   ├── api/                              # API相关
│   │   └── ApiResponse.java             # 统一返回体
│   ├── enums/                            # 枚举类
│   │   ├── BaseEnum.java                # 枚举基础接口
│   │   └── ErrorCode.java               # 错误码枚举
│   ├── exception/                        # 异常处理 ✨ 新增
│   │   ├── BusinessException.java       # 业务异常
│   │   └── GlobalExceptionHandler.java  # 全局异常处理器
│   ├── log/                              # 日志组件 ✨ 新增
│   │   └── TraceIdFilter.java           # 链路追踪过滤器
│   └── security/                         # 安全组件
│       ├── SecurityUtil.java            # 安全工具类
│       ├── UserPrincipal.java           # 用户认证主体
│       ├── JwtAuthenticationFilter.java # JWT认证过滤器
│       ├── RestAuthenticationEntryPoint.java    # 未认证处理器
│       ├── RestAccessDeniedHandler.java         # 权限不足处理器
│       ├── EncryptedField.java          # 加密字段注解
│       └── EncryptedTypeHandler.java    # 加密字段处理器
├── config/                                # 配置类
│   ├── MybatisPlusConfig.java           # MyBatis-Plus配置
│   ├── RedisConfig.java                 # Redis配置
│   ├── SecurityConfig.java              # Spring Security配置
│   └── Knife4jConfig.java               # Knife4j配置 ✨ 新增
└── util/                                  # 工具类
    ├── PageUtil.java                     # 分页工具类
    └── CryptoUtil.java                   # 加密工具类
```

---

## 📝 代码编写规范

### 实体类规范

#### 1. 基础实体类 (BaseEntity)

所有实体类必须继承 `BaseEntity`，它提供了通用的基础字段：

```java
@Data
public abstract class BaseEntity implements Serializable {
    
    /**
     * 主键ID - 使用雪花算法自动生成
     * @TableId: MyBatis-Plus主键注解
     * - value: 数据库字段名
     * - type: 主键生成策略，ASSIGN_ID使用雪花算法
     */
    @TableId(value = "id", type = IdType.ASSIGN_ID)
    private Long id;

    /**
     * 创建时间 - 插入时自动填充
     * @TableField: MyBatis-Plus字段注解
     * - value: 数据库字段名
     * - fill: 自动填充策略，INSERT表示插入时填充
     */
    @TableField(value = "create_at", fill = FieldFill.INSERT)
    private LocalDateTime createAt;

    /**
     * 更新时间 - 插入和更新时自动填充
     * - fill: INSERT_UPDATE表示插入和更新时都填充
     */
    @TableField(value = "update_at", fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateAt;

    /**
     * 创建人 - 插入时自动填充
     */
    @TableField(value = "create_by", fill = FieldFill.INSERT)
    private Long createBy;

    /**
     * 更新人 - 插入和更新时自动填充
     */
    @TableField(value = "update_by", fill = FieldFill.INSERT_UPDATE)
    private Long updateBy;

    /**
     * 逻辑删除标识 - 0: 未删除, 1: 已删除
     * @TableLogic: MyBatis-Plus逻辑删除注解
     * - value: 未删除时的值
     * - delval: 删除时的值
     */
    @TableLogic(value = "0", delval = "1")
    @TableField("is_deleted")
    private Integer isDeleted;
}
```

**关键注解说明**:
- `@Data`: Lombok注解，自动生成getter/setter/toString/equals/hashCode方法
- `@TableId`: 标识主键字段，配置主键生成策略
- `@TableField`: 配置字段映射和自动填充策略
- `@TableLogic`: 配置逻辑删除字段

#### 2. 业务实体类 (User)

```java
/**
 * 用户实体类
 * @Data: Lombok注解，生成getter/setter等方法
 * @EqualsAndHashCode(callSuper = true): 生成equals和hashCode时包含父类字段
 * @TableName: 指定数据库表名
 */
@Data
@EqualsAndHashCode(callSuper = true)
@TableName("sys_user")
public class User extends BaseEntity {

    /**
     * 用户名
     * @TableField: 指定数据库字段名
     */
    @TableField("username")
    private String username;

    /**
     * 密码（BCrypt加密）
     */
    @TableField("password")
    private String password;

    /**
     * 真实姓名
     */
    @TableField("real_name")
    private String realName;

    /**
     * 手机号
     */
    @TableField("phone")
    private String phone;

    /**
     * 邮箱
     */
    @TableField("email")
    private String email;

    /**
     * 头像URL
     */
    @TableField("avatar")
    private String avatar;

    /**
     * 账号状态：0-启用，1-禁用
     */
    @TableField("status")
    private Integer status;

    /**
     * 用户角色列表（不存储在数据库中，通过关联查询获取）
     * @TableField(exist = false): 表示该字段不对应数据库字段
     */
    @TableField(exist = false)
    private List<String> roles;
}
```

### Controller 层规范

#### 1. 基础注解配置

```java
/**
 * 认证授权 Controller
 * @Tag: Swagger文档注解，定义接口分组
 * @RestController: Spring MVC注解，标识REST控制器，自动将返回值序列化为JSON
 * @RequestMapping: 定义控制器的基础路径
 * @RequiredArgsConstructor: Lombok注解，为final字段生成构造函数
 * @Validated: 启用方法级别的参数校验
 */
@Tag(name = "认证授权", description = "登录、注册相关接口")
@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
@Validated
public class AuthController {
    // Controller实现
}
```

#### 2. 接口方法规范

```java
/**
 * @Operation: Swagger文档注解，描述接口功能
 * @PostMapping: Spring MVC注解，处理POST请求
 * @RequestBody: 将请求体JSON转换为Java对象
 * @Valid: 启用Bean Validation校验
 */
@Operation(summary = "用户登录", description = "验证用户名密码，返回 Token")
@PostMapping("/login")
public ApiResponse<String> login(@RequestBody @Valid AuthRequests.LoginRequest request) {
    // TODO: 实现登录逻辑
    return ApiResponse.success("mock-token-12345");
}
```

#### 3. 统一返回格式

所有接口必须使用 `ApiResponse` 统一返回格式：

```java
// 成功响应（无数据）
return ApiResponse.success();

// 成功响应（带数据）
return ApiResponse.success(data);

// 成功响应（自定义消息）
return ApiResponse.success("操作成功", data);

// 失败响应
return ApiResponse.error(ErrorCode.USER_NOT_FOUND);

return ApiResponse.error(ErrorCode.USER_NOT_FOUND, message)

return ApiResponse.error(ErrorCode.USER_NOT_FOUND, message, data);
```

### Service 层规范

#### 1. 接口和实现分离

```java
// 服务接口
public interface UserService {
    User getByUsername(String username);
    User getById(Long id);
    void create(User user);
    void update(User user);
    void delete(Long id);
    PageResponse<User> list(Integer pageNum, Integer pageSize, String keyword);
}
```

#### 2. 服务实现类

```java
/**
 * 用户服务实现类
 * @Service: Spring注解，标识服务层组件
 * @RequiredArgsConstructor: Lombok注解，为final字段生成构造函数
 * @Transactional(readOnly = true): 类级别事务，默认只读事务
 */
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class UserServiceImpl implements UserService {

   private final UserMapper userMapper;

   @Override
   public User getByUsername(String username) {
      return userMapper.selectByUsername(username);
   }

   @Override
   public User getById(Long id) {
      return userMapper.selectById(id);
   }

   @Override
   @Transactional(rollbackFor = Exception.class)
   public void create(User user) {
      userMapper.insert(user);
   }

   @Override
   @Transactional(rollbackFor = Exception.class)
   public void update(User user) {
      userMapper.updateById(user);
   }

   @Override
   @Transactional(rollbackFor = Exception.class)
   public void delete(Long id) {
      userMapper.deleteById(id);
   }

   @Override
   public PageResponse<User> list(Integer pageNum, Integer pageSize, String keyword) {
      // 使用 MyBatis-Plus 分页
      IPage<User> page = userMapper.selectUsersByKeyword(new Page<>(pageNum, pageSize), keyword);
      return PageUtil.toPageResponse(page);
   }
}
```

**关键注解说明**:
- `@Service`: 标识服务层组件，Spring会自动扫描并注册为Bean
- `@Transactional`: 声明式事务管理
  - `readOnly = true`: 只读事务，优化性能
  - `rollbackFor = Exception.class`: 遇到任何异常都回滚

默认情况下，只有当事务中的代码抛出Unchecked Exceptions时才会回滚（如 NullPointerException, IllegalArgumentException），而Checked Exceptions（如 IOException, SQLException）不会回滚。

使用`@Transactional(rollbackFor = Exception.class)`可以保证除了默认的 RuntimeException 和 Error，当方法抛出任何 Exception 及其子类的实例时，都回滚当前事务.

**注意**：严禁在ServiceImpl中使用queryWrapper，所有sql操作都必须在mapper层中实现，简单的可以通过注解写sql语句，复杂的在xml中写sql语句。

### Mapper 层规范

#### 1. Mapper接口定义

```java
/**
 * 用户 Mapper 接口
 * @Mapper: MyBatis注解，标识Mapper接口
 * extends BaseMapper<User>: 继承MyBatis-Plus基础Mapper，获得基本CRUD方法
 */
@Mapper
public interface UserMapper extends BaseMapper<User> {

   /**
    * 根据用户名查询用户 - 简单查询，使用注解
    */
   @Select("SELECT * FROM sys_user WHERE username = #{username} AND is_deleted = 0")
   User selectByUsername(@Param("username") String username);

   /**
    * 根据手机号查询用户 - 简单查询，使用注解
    */
   @Select("SELECT * FROM sys_user WHERE phone = #{phone} AND is_deleted = 0")
   User selectByPhone(@Param("phone") String phone);

   /**
    * 根据邮箱查询用户 - 简单查询，使用注解
    */
   @Select("SELECT * FROM sys_user WHERE email = #{email} AND is_deleted = 0")
   User selectByEmail(@Param("email") String email);

   /**
    * 根据关键词分页查询用户列表 - 复杂查询，使用XML实现
    */
   List<User> selectUsersByKeyword(@Param("keyword") String keyword);
}

```

**关键注解说明**:
- `@Mapper`: 标识MyBatis Mapper接口，Spring会自动创建代理实现
- `@Param`: 为方法参数指定名称，在XML映射文件中使用

#### 2. 查询策略规范

**重要规范**: 本项目采用分层查询策略，禁止在 Service 层使用 QueryWrapper 或 LambdaQueryWrapper。

**查询策略**:
1. **简单查询**：使用 `@Select` 注解直接在 Mapper 接口中定义 SQL
2. **复杂查询**：使用 XML 映射文件定义 SQL（动态条件、多表JOIN等）

**示例**:
```java
// 简单查询 - 使用注解
@Select("SELECT * FROM sys_user WHERE username = #{username} AND is_deleted = 0")
User selectByUsername(@Param("username") String username);

// 复杂查询 - 使用XML（动态模糊查询）
List<User> selectUsersByKeyword(@Param("keyword") String keyword);
```

**XML映射文件规范** (仅用于复杂查询):

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.dawnmoon.springboot_app_template.mapper.UserMapper">

    <!-- 只包含复杂的查询逻辑（动态条件、多表JOIN等） -->
    <!-- 简单查询直接在Mapper接口中使用 @Select 注解定义 -->

    <!-- 根据关键词分页查询用户列表 - 复杂查询，使用XML实现 -->
    <select id="selectUsersByKeyword" resultType="com.dawnmoon.springboot_app_template.model.entity.User">
        SELECT * FROM sys_user
        WHERE is_deleted = 0
        <if test="keyword != null and keyword != ''">
            AND (
                username LIKE CONCAT('%', #{keyword}, '%')
                OR real_name LIKE CONCAT('%', #{keyword}, '%')
                OR phone LIKE CONCAT('%', #{keyword}, '%')
                OR email LIKE CONCAT('%', #{keyword}, '%')
            )
        </if>
        ORDER BY create_at DESC
    </select>

</mapper>
```

**XML映射规范**:
- 文件名必须与 Mapper 接口名一致：`UserMapper.xml`
- namespace 必须与 Mapper 接口全限定名一致
- 只包含复杂的查询逻辑，简单查询使用注解
- 所有查询必须包含 `AND is_deleted = 0`（逻辑删除条件）
- 使用 `<if>` 标签进行条件判断，避免动态拼接
- 使用 CONCAT 函数进行模糊查询

---

## ⚙️ 配置管理规范

### 多环境配置规范

#### 1. 配置文件层次结构

```
application.yaml          # 基础配置（所有环境通用）
├── application-dev.yaml  # 开发环境配置
├── application-test.yaml # 测试环境配置
└── application-prod.yaml # 生产环境配置
```

#### 2. 基础配置文件 (application.yaml)

```yaml
spring:
  application:
    name: springboot-app-template
  # 激活的配置文件 - 通过 Maven profiles 或启动参数切换
  profiles:
    active: @profileActive@

# MyBatis-Plus 基础配置
mybatis-plus:
  # Mapper XML 文件位置
  mapper-locations: classpath*:/mapper/**/*.xml
  # 实体类包路径
  type-aliases-package: com.dawnmoon.springboot_app_template.model.entity
  
  configuration:
    # 驼峰命名转换：数据库下划线 -> Java驼峰
    map-underscore-to-camel-case: true
    # 自动映射策略：FULL 完全映射
    auto-mapping-behavior: full
    # NULL 值处理
    jdbc-type-for-null: 'null'
    # 日志实现
    log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl

  global-config:
    # 关闭 MyBatis-Plus banner
    banner: false
    db-config:
      # 主键类型：雪花算法
      id-type: ASSIGN_ID
      # 逻辑删除字段名（全局配置）
      logic-delete-field: isDeleted
      # 逻辑删除值（删除后的值）
      logic-delete-value: 1
      # 逻辑未删除值（正常值）
      logic-not-delete-value: 0

# MyBatis-Plus 分页插件由 MybatisPlusInterceptor + PaginationInnerInterceptor 启用
```

#### 3. 开发环境配置 (application-dev.yaml)

```yaml
server:
  port: 8080

spring:
  # 数据源配置 - MySQL
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/springboot_template?useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai&useSSL=false
    username: root
    password: root

    # Hikari 连接池配置
    hikari:
      minimum-idle: 5          # 最小空闲连接数
      maximum-pool-size: 20    # 最大连接数
      connection-timeout: 30000 # 连接超时时间（毫秒）
      max-lifetime: 1800000    # 最大生命周期（毫秒）
      idle-timeout: 600000     # 空闲超时时间（毫秒）
      connection-test-query: SELECT 1  # 连接测试查询

  # Redis 配置
  data:
    redis:
      host: localhost
      port: 6379
      password:
      database: 0
      timeout: 5000ms
      lettuce:
        pool:
          max-active: 20
          max-wait: -1ms
          max-idle: 10
          min-idle: 0

# P6Spy SQL 监控配置（开发环境启用）
decorator:
  datasource:
    p6spy:
      enable: true
      logging: slf4j
      multiline: true

# 无需额外配置数据库方言，插件自动识别

# 日志级别配置 - 开发环境详细日志
logging:
  level:
    root: INFO
    com.dawnmoon.springboot_app_template: DEBUG
    com.dawnmoon.springboot_app_template.mapper: DEBUG
  pattern:
    console: '[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%thread] [%-5level] [%X{traceId}] %logger{36} - %msg%n'
```

#### 4. 生产环境配置 (application-prod.yaml)

```yaml
server:
  port: 8080

spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    # 使用环境变量配置敏感信息
    url: jdbc:mysql://${DB_HOST:localhost}:${DB_PORT:3306}/${DB_NAME:springboot_template}?useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai&useSSL=true
    username: ${DB_USERNAME:root}
    password: ${DB_PASSWORD:}
    hikari:
      minimum-idle: 10
      maximum-pool-size: 50
      connection-timeout: 30000

  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:}
      database: 0

# 生产环境关闭SQL监控
decorator:
  datasource:
    p6spy:
      enable: false

# 生产环境日志级别
logging:
  level:
    root: WARN
    com.dawnmoon.springboot_app_template: INFO
```

---

## 📊 数据访问规范

### MyBatis-Plus 配置

#### 1. 配置类 (MybatisPlusConfig)

```java
/**
 * MyBatis-Plus 配置类
 * @Configuration: Spring配置类注解
 * @MapperScan: 指定Mapper接口扫描包路径
 */
@Configuration
@MapperScan("com.dawnmoon.springboot_app_template.mapper")
public class MybatisPlusConfig {

    /**
     * 自动填充处理器
     * @Slf4j: Lombok注解，自动生成log字段
     * @Component: Spring组件注解，注册为Bean
     */
    @Slf4j
    @Component
    public static class MyMetaObjectHandler implements MetaObjectHandler {

        @Override
        public void insertFill(MetaObject metaObject) {
            log.debug("开始插入填充...");

            // 填充创建时间和更新时间
            this.strictInsertFill(metaObject, "createAt", LocalDateTime.class, LocalDateTime.now());
            this.strictInsertFill(metaObject, "updateAt", LocalDateTime.class, LocalDateTime.now());

            // 填充创建人和更新人（从当前登录用户获取）
            Long currentUserId = SecurityUtil.getCurrentUserId();
            if (currentUserId != null) {
                this.strictInsertFill(metaObject, "createBy", Long.class, currentUserId);
                this.strictInsertFill(metaObject, "updateBy", Long.class, currentUserId);
            }
        }

        @Override
        public void updateFill(MetaObject metaObject) {
            log.debug("开始更新填充...");

            // 填充更新时间和更新人
            this.strictUpdateFill(metaObject, "updateAt", LocalDateTime.class, LocalDateTime.now());

            Long currentUserId = SecurityUtil.getCurrentUserId();
            if (currentUserId != null) {
                this.strictUpdateFill(metaObject, "updateBy", Long.class, currentUserId);
            }
        }
    }
}
```

**关键接口说明**:
- `MetaObjectHandler`: MyBatis-Plus自动填充处理器接口
- `strictInsertFill()`: 严格模式插入填充，只有字段为null时才填充
- `strictUpdateFill()`: 严格模式更新填充

#### 2. 分页查询规范

**重要规范**: 本项目禁止使用 MyBatis-Plus 的 QueryWrapper 或 LambdaQueryWrapper 进行动态查询。所有数据库查询必须通过 Mapper 接口中定义的注解 SQL 或 XML 映射文件实现。

**替代方案**:
1. 在 Mapper 接口中定义自定义查询方法
2. 在 XML 映射文件中编写对应的 SQL 语句
3. 在 Service 中调用自定义的 Mapper 方法

```java
// 使用 MyBatis-Plus 进行分页
public PageResponse<User> list(Integer pageNum, Integer pageSize, String keyword) {
    IPage<User> page = userMapper.selectUsersByKeyword(new Page<>(pageNum, pageSize), keyword);
    return PageUtil.toPageResponse(page);
}
```

**分页工具类 (PageUtil)**:

```java
/**
 * 分页工具类
 * 提供 IPage 到 PageResponse 的转换方法
 */
public class PageUtil {

    /**
     * 将 IPage 转换为 PageResponse
     */
    public static <T> PageResponse<T> toPageResponse(IPage<T> page) {
        PageResponse<T> response = new PageResponse<>();
        response.setTotal(page.getTotal());
        response.setPageNum((int) page.getCurrent());
        response.setPageSize((int) page.getSize());
        response.setPages((int) page.getPages());
        response.setList(page.getRecords());
        return response;
    }

    /**
     * 将 IPage 转换为 PageResponse，并对列表进行转换
     * 用于Entity到VO的转换
     */
    public static <S, T> PageResponse<T> toPageResponse(IPage<S> page, Function<S, T> converter) {
        PageResponse<T> response = new PageResponse<>();
        response.setTotal(page.getTotal());
        response.setPageNum((int) page.getCurrent());
        response.setPageSize((int) page.getSize());
        response.setPages((int) page.getPages());

        List<T> convertedList = page.getRecords().stream()
                .map(converter)
                .collect(Collectors.toList());
        response.setList(convertedList);

        return response;
    }
}
```

---

## 📋 API 设计规范

### 统一返回体 (ApiResponse)

#### 1. 返回体结构

```java
/**
 * 统一 API 返回格式
 * @Data: Lombok注解，生成getter/setter方法
 * @NoArgsConstructor/@AllArgsConstructor: Lombok注解，生成构造函数
 * @JsonInclude(JsonInclude.Include.NON_NULL): Jackson注解，null值不序列化
 * @Schema: Swagger文档注解，描述响应体结构
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
@Schema(description = "统一响应体")
public class ApiResponse<T> implements Serializable {

    @Schema(description = "响应码", example = "SUCCESS")
    private String code;

    @Schema(description = "响应消息", example = "操作成功")
    private String message;

    @Schema(description = "响应数据")
    private T data;

    @Schema(description = "时间戳", example = "1719876543210")
    private Long timestamp;

    // 静态工厂方法
    public static <T> ApiResponse<T> success() {
        return new ApiResponse<>(
            ErrorCode.SUCCESS.getCode(),
            ErrorCode.SUCCESS.getDescription(),
            null,
            System.currentTimeMillis()
        );
    }

    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(
            ErrorCode.SUCCESS.getCode(),
            ErrorCode.SUCCESS.getDescription(),
            data,
            System.currentTimeMillis()
        );
    }

    public static <T> ApiResponse<T> error(ErrorCode errorCode) {
        return new ApiResponse<>(
            errorCode.getCode(),
            errorCode.getDescription(),
            null,
            System.currentTimeMillis()
        );
    }
}
```

#### 2. 错误码枚举 (ErrorCode)

```java
/**
 * 统一错误码枚举
 * @Getter: Lombok注解，生成getter方法
 * implements BaseEnum<String>: 实现基础枚举接口
 */
@Getter
public enum ErrorCode implements BaseEnum<String> {

    // 成功
    SUCCESS("SUCCESS", "操作成功"),

    // 客户端错误 4xx
    BAD_REQUEST("BAD_REQUEST", "请求参数错误"),
    UNAUTHORIZED("UNAUTHORIZED", "未认证或认证已过期"),
    FORBIDDEN("FORBIDDEN", "没有访问权限"),
    NOT_FOUND("NOT_FOUND", "请求的资源不存在"),
    VALIDATE_FAILED("VALIDATE_FAILED", "参数校验失败"),

    // 业务错误 5xx
    BUSINESS_ERROR("BUSINESS_ERROR", "业务处理失败"),
    INTERNAL_SERVER_ERROR("INTERNAL_SERVER_ERROR", "服务器内部错误"),

    // 用户相关错误
    USER_NOT_FOUND("USER_NOT_FOUND", "用户不存在"),
    USER_ALREADY_EXISTS("USER_ALREADY_EXISTS", "用户已存在"),
    USERNAME_OR_PASSWORD_ERROR("USERNAME_OR_PASSWORD_ERROR", "用户名或密码错误");

    private final String code;
    private final String description;

    ErrorCode(String code, String description) {
        this.code = code;
        this.description = description;
    }

    @Override
    public String getCode() {
        return code;
    }

    @Override
    public String getDescription() {
        return description;
    }
}
```

### 请求参数规范

#### 1. 请求对象定义

```java
/**
 * 认证相关请求对象
 * 使用内部静态类组织相关的请求对象
 */
public class AuthRequests {

    /**
     * 登录请求
     * @Data: Lombok注解
     * @Schema: Swagger文档注解，描述请求体
     */
    @Data
    @Schema(description = "登录请求")
    public static class LoginRequest {

        /**
         * @Schema: Swagger字段描述
         * @NotBlank: Bean Validation注解，不能为null且去除空白字符后长度大于0
         * @Size: Bean Validation注解，限制字符串长度
         */
        @Schema(description = "用户名", example = "admin")
        @NotBlank(message = "用户名不能为空")
        @Size(min = 3, max = 50, message = "用户名长度必须在3-50个字符之间")
        private String username;

        @Schema(description = "密码", example = "123456")
        @NotBlank(message = "密码不能为空")
        @Size(min = 6, max = 100, message = "密码长度必须在6-100个字符之间")
        private String password;
    }
}
```

**Bean Validation 注解说明**:
- `@NotBlank`: 字符串不能为null、空字符串或只包含空白字符
- `@NotNull`: 值不能为null
- `@Size`: 限制字符串、集合、数组的大小
- `@Min/@Max`: 限制数字的最小/最大值
- `@Email`: 验证邮箱格式
- `@Pattern`: 正则表达式验证

---

## 📚 开发流程规范

### 新功能开发流程

#### 1. 实体类开发
```java
// 1. 继承BaseEntity
public class NewEntity extends BaseEntity {
    // 2. 添加业务字段
    // 3. 使用合适的MyBatis-Plus注解
}
```

#### 2. Mapper开发
```java
// 1. 继承BaseMapper获得基础CRUD
@Mapper
public interface NewEntityMapper extends BaseMapper<NewEntity> {
    // 2. 添加自定义查询方法
}
```

#### 3. Service开发
```java
// 1. 定义服务接口
public interface NewEntityService {
    // 定义业务方法
}

// 2. 实现服务类
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class NewEntityServiceImpl implements NewEntityService {
    // 实现业务逻辑
}
```

#### 4. Controller开发
```java
// 1. 添加必要注解
@RestController
@RequestMapping("/api/newentity")
@RequiredArgsConstructor
@Validated
public class NewEntityController {
    // 2. 实现REST接口
    // 3. 使用统一返回格式
}
```

### 代码提交规范

#### 1. 提交信息格式
```
<type>: <subject>

<body>
```

#### 2. 提交类型
- **feat**: 新功能
- **fix**: 修复bug
- **doc**: 文档更新
- **refactor**: 代码重构
- **test**: 测试相关

#### 3. 提交示例
```
feat: 添加用户分页查询功能

- 实现用户列表分页查询API
- 支持按用户名、手机号模糊搜索
- 添加相关单元测试
```

---

## 🎯 最佳实践总结

### 代码质量最佳实践

1. **注解使用规范**
   - 合理使用Lombok注解减少样板代码
   - 正确配置MyBatis-Plus注解实现自动化
   - 使用Bean Validation注解进行参数校验
   - 添加Swagger注解完善API文档

2. **分层架构实践**
   - Controller层只处理HTTP请求响应
   - Service层处理业务逻辑和事务
   - Mapper层只负责数据访问
   - 使用统一的返回格式和错误处理

3. **配置管理实践**
   - 多环境配置分离
   - 敏感信息使用环境变量
   - 合理配置连接池和缓存参数

4. **数据访问实践**
   - 继承BaseEntity统一基础字段
   - 使用逻辑删除避免物理删除
   - 合理使用分页查询避免大数据量问题
   - 利用自动填充简化审计字段管理

### 开发效率提升

1. **工具链优化**
   - 使用Lombok减少getter/setter编写
   - 使用MyBatis-Plus减少基础CRUD与分页实现
   - 使用P6Spy监控SQL执行

2. **代码复用**
   - BaseEntity提供通用字段
   - ApiResponse统一返回格式
   - PageUtil统一分页转换
   - ErrorCode统一错误码管理

---

## 🔒 安全与认证规范（阶段三）

### Spring Security 6.x 配置规范

#### 1. SecurityConfig 配置类

Spring Security 6.x 使用 SecurityFilterChain Bean 替代 WebSecurityConfigurerAdapter：

```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity // 启用方法级安全注解
@RequiredArgsConstructor
public class SecurityConfig {
    
    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    private final RestAuthenticationEntryPoint restAuthenticationEntryPoint;
    private final RestAccessDeniedHandler restAccessDeniedHandler;
    
    /**
     * 白名单 - 不需要认证的路径
     */
    private static final String[] AUTH_WHITELIST = {
        "/api/auth/login",
        "/api/auth/register",
        "/doc.html",
        "/swagger-ui.html",
        "/swagger-ui/**",
        "/v3/api-docs/**",
        "/webjars/**",
        "/favicon.ico",
        "/error"
    };
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // 禁用 CSRF（前后端分离项目）
            .csrf(AbstractHttpConfigurer::disable)
            
            // 配置授权规则
            .authorizeHttpRequests(authorize -> authorize
                .requestMatchers(AUTH_WHITELIST).permitAll()
                .anyRequest().authenticated()
            )
            
            // 配置会话管理（无状态）
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            
            // 配置异常处理
            .exceptionHandling(exception -> exception
                .authenticationEntryPoint(restAuthenticationEntryPoint)
                .accessDeniedHandler(restAccessDeniedHandler)
            )
            
            // 添加 JWT 过滤器
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

**关键点**：
- 使用 Lambda DSL 配置（Spring Security 6.x 推荐方式）
- 无状态会话管理（SessionCreationPolicy.STATELESS）
- 自定义异常处理器
- JWT 认证过滤器

#### 2. JWT 认证过滤器

```java
@Slf4j
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    private final RedisTemplate<String, Object> redisTemplate;
    
    @Value("${app.security.token.prefix:token:}")
    private String tokenPrefix;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                  HttpServletResponse response,
                                  FilterChain filterChain) throws ServletException, IOException {
        
        // 1. 从请求头获取 Token
        String token = getTokenFromRequest(request);
        
        if (StringUtils.hasText(token)) {
            // 2. 从 Redis 获取用户信息
            String redisKey = tokenPrefix + token;
            UserPrincipal userPrincipal = (UserPrincipal) redisTemplate.opsForValue().get(redisKey);
            
            if (userPrincipal != null) {
                // 3. 创建认证对象并设置到 SecurityContext
                UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken(
                        userPrincipal,
                        null,
                        userPrincipal.getAuthorities()
                    );
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authentication);
                
                // 4. 刷新 Token 过期时间（滑动过期）
                Long ttl = redisTemplate.getExpire(redisKey, TimeUnit.SECONDS);
                if (ttl != null && ttl > 0 && ttl < 3600) {
                    redisTemplate.expire(redisKey, 24, TimeUnit.HOURS);
                }
            }
        }
        
        filterChain.doFilter(request, response);
    }
    
    private String getTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

**关键点**：
- 继承 OncePerRequestFilter 确保每个请求只执行一次
- 从 Redis 中获取用户信息（而不是解析 JWT）
- 实现滑动过期机制
- Token 格式：`Authorization: Bearer {token}`

### Redis Token 认证机制

#### 1. 双 Key 结构设计

为实现单点登录和快速查询，使用两种 Redis Key：

```
1. token:{token} → UserPrincipal 对象
   - 用途：根据 Token 快速获取用户信息
   - 过期时间：24小时（可配置）
   
2. user_id_to_token:{userId} → Token 字符串
   - 用途：根据 userId 查找当前有效的 Token
   - 过期时间：与 token:{token} 相同
```

**优势**：
- 支持单点登录/互踢机制
- 支持管理员强制用户下线
- 支持查询在线用户数和登录时间

#### 2. AuthService 实现

```java
@Slf4j
@Service
@RequiredArgsConstructor
public class AuthServiceImpl implements AuthService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final UserService userService;
    private final PasswordEncoder passwordEncoder;
    
    @Value("${app.security.token.prefix:token:}")
    private String tokenKeyPrefix;
    
    @Value("${app.security.token.ttl:86400}")
    private long tokenTtlSeconds;
    
    private static final String USER_ID_TO_TOKEN_KEY_PREFIX = "user_id_to_token:";
    
    @Override
    public String login(AuthRequests.LoginRequest request) {
        // 1. 验证用户名和密码
        User user = userService.getByUsername(request.getUsername());
        if (user == null || !passwordEncoder.matches(request.getPassword(), user.getPassword())) {
            throw new BusinessException(ErrorCode.USERNAME_OR_PASSWORD_ERROR);
        }
        
        // 2. 检查账号状态
        if (!user.getEnabled()) {
            throw new BusinessException(ErrorCode.USER_ACCOUNT_DISABLED);
        }
        
        // 3. 踢出旧设备（单点登录）
        String oldToken = (String) redisTemplate.opsForValue()
            .get(USER_ID_TO_TOKEN_KEY_PREFIX + user.getId());
        if (StringUtils.hasText(oldToken)) {
            redisTemplate.delete(tokenKeyPrefix + oldToken);
        }
        
        // 4. 生成新 Token
        String newToken = UUID.randomUUID().toString().replace("-", "");
        
        // 5. 创建 UserPrincipal 对象（包含登录时间）
        UserPrincipal userPrincipal = new UserPrincipal(
            user.getId(),
            user.getUsername(),
            null,
            user.getRoles(),
            user.getEnabled(),
            System.currentTimeMillis()
        );
        
        // 6. 存储到 Redis
        redisTemplate.opsForValue().set(tokenKeyPrefix + newToken, userPrincipal, 
                                         tokenTtlSeconds, TimeUnit.SECONDS);
        redisTemplate.opsForValue().set(USER_ID_TO_TOKEN_KEY_PREFIX + user.getId(), newToken,
                                         tokenTtlSeconds, TimeUnit.SECONDS);
        
        return newToken;
    }
    
    @Override
    public void logoutSelf(String token) {
        // 用户自己退出登录
        String tokenKey = tokenKeyPrefix + token;
        UserPrincipal userPrincipal = (UserPrincipal) redisTemplate.opsForValue().get(tokenKey);
        
        if (userPrincipal != null) {
            redisTemplate.delete(tokenKey);
            redisTemplate.delete(USER_ID_TO_TOKEN_KEY_PREFIX + userPrincipal.getUserId());
        }
    }
    
    @Override
    public void forceLogoutByAdmin(Long targetUserId) {
        // 管理员强制用户下线
        String token = (String) redisTemplate.opsForValue()
            .get(USER_ID_TO_TOKEN_KEY_PREFIX + targetUserId);
        
        if (StringUtils.hasText(token)) {
            redisTemplate.delete(tokenKeyPrefix + token);
            redisTemplate.delete(USER_ID_TO_TOKEN_KEY_PREFIX + targetUserId);
        }
    }
}
```

### 加密工具规范

**重要说明**：本项目采用手动加密方式，不使用自动加解密组件（如 TypeHandler），确保加密逻辑的明确性和可控性。

#### 1. BCrypt 密码加密

**用途**：用户密码存储（不可逆哈希）

```java
@Component
public class CryptoUtil {
    
    private static final BCryptPasswordEncoder PASSWORD_ENCODER = new BCryptPasswordEncoder();
    
    /**
     * BCrypt 加密
     */
    public static String bcryptEncode(String password) {
        return PASSWORD_ENCODER.encode(password);
    }
    
    /**
     * BCrypt 验证
     */
    public static boolean bcryptMatches(String rawPassword, String encodedPassword) {
        return PASSWORD_ENCODER.matches(rawPassword, encodedPassword);
    }
}
```

**使用场景**：
- 用户注册时加密密码
- 用户登录时验证密码
- 密码重置时加密新密码

#### 2. ECC 敏感数据加密

**用途**：敏感字段加密（可逆加密，如手机号、身份证号）
**注意**：需要手动调用，不使用自动加解密

```java
@Component
public class CryptoUtil {
    
    @Value("${app.crypto.ecc.public-key:}")
    private String eccPublicKeyStr;
    
    @Value("${app.crypto.ecc.private-key:}")
    private String eccPrivateKeyStr;
    
    private PublicKey eccPublicKey;
    private PrivateKey eccPrivateKey;
    
    static {
        Security.addProvider(new BouncyCastleProvider());
    }
    
    @PostConstruct
    public void init() {
        // 从配置加载密钥
        if (eccPublicKeyStr != null && !eccPublicKeyStr.isEmpty()) {
            eccPublicKey = loadPublicKey(eccPublicKeyStr);
        }
        if (eccPrivateKeyStr != null && !eccPrivateKeyStr.isEmpty()) {
            eccPrivateKey = loadPrivateKey(eccPrivateKeyStr);
        }
    }
    
    /**
     * ECC 加密
     */
    public String eccEncrypt(String data) throws Exception {
        Cipher cipher = Cipher.getInstance("ECIES", "BC");
        cipher.init(Cipher.ENCRYPT_MODE, eccPublicKey);
        byte[] encrypted = cipher.doFinal(data.getBytes(StandardCharsets.UTF_8));
        return Base64.getEncoder().encodeToString(encrypted);
    }
    
    /**
     * ECC 解密
     */
    public String eccDecrypt(String cipherText) throws Exception {
        Cipher cipher = Cipher.getInstance("ECIES", "BC");
        cipher.init(Cipher.DECRYPT_MODE, eccPrivateKey);
        byte[] decrypted = cipher.doFinal(Base64.getDecoder().decode(cipherText));
        return new String(decrypted, StandardCharsets.UTF_8);
    }
}
```

**使用方式**：

```java
// 手动加密敏感数据 - 在业务层处理
@Service
public class UserServiceImpl implements UserService {
    
    private final CryptoUtil cryptoUtil;
    
    public void saveUser(User user) {
        // 手动加密手机号
        if (user.getPhone() != null) {
            String encryptedPhone = cryptoUtil.eccEncrypt(user.getPhone());
            user.setPhone(encryptedPhone);
        }
        userMapper.insert(user);
    }

    public User getUser(Long id) {
        User user = userMapper.selectById(id);
        if (user != null && user.getPhone() != null) {
            // 手动解密手机号
            String decryptedPhone = cryptoUtil.eccDecrypt(user.getPhone());
            user.setPhone(decryptedPhone);
        }
        return user;
    }
}
```

### 角色权限管理规范

#### 1. 实体类设计

```java
// 角色表
@TableName("sys_role")
public class Role extends BaseEntity {
    @TableField("role_name")
    private String roleName;  // 如：ADMIN、USER、GUEST
    
    @TableField("description")
    private String description;
    
    @TableField("status")
    private Integer status;   // 0-启用，1-禁用
}

// 用户角色关联表
@TableName("sys_user_role")
public class UserRole extends BaseEntity {
    @TableField("user_id")
    private Long userId;
    
    @TableField("role_id")
    private Long roleId;
}

// 用户表（添加角色字段）
public class User extends BaseEntity {
    // ... 其他字段
    
    @TableField(exist = false)
    private List<String> roles;  // 角色列表（不存储在数据库，通过关联查询获取）
    
    public Boolean getEnabled() {
        return status != null && status == 0;
    }
}
```

#### 2. 角色查询

```java
@Mapper
public interface UserRoleMapper extends BaseMapper<UserRole> {
    
    /**
     * 根据用户ID查询角色名称列表
     */
    @Select("SELECT r.role_name FROM sys_role r " +
            "INNER JOIN sys_user_role ur ON r.id = ur.role_id " +
            "WHERE ur.user_id = #{userId} AND r.is_deleted = 0 AND ur.is_deleted = 0")
    List<String> selectRoleNamesByUserId(Long userId);
}

// 在 UserService 中加载角色
public User getByUsername(String username) {
    User user = userMapper.selectByUsername(username);
    if (user != null) {
        user.setRoles(userRoleMapper.selectRoleNamesByUserId(user.getId()));
    }
    return user;
}
```

#### 3. 权限注解使用

```java
@RestController
@RequestMapping("/api/admin")
public class AdminController {
    
    /**
     * 管理员专用接口
     */
    @PreAuthorize("hasRole('ADMIN')")
    @GetMapping("/users")
    public ApiResponse<List<User>> getAllUsers() {
        // ...
    }
    
    /**
     * 需要 ADMIN 或 MANAGER 角色
     */
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @PostMapping("/users")
    public ApiResponse<Void> createUser() {
        // ...
    }
}
```

### 数据库脚本规范

#### 1. DDL 脚本规范

**MySQL 示例**：

```sql
-- 用户表
CREATE TABLE `sys_user` (
    `id` BIGINT NOT NULL COMMENT '主键ID（雪花算法）',
    `username` VARCHAR(50) NOT NULL COMMENT '用户名',
    `password` VARCHAR(255) NOT NULL COMMENT '密码（BCrypt加密）',
    `real_name` VARCHAR(50) NULL COMMENT '真实姓名',
    `phone` VARCHAR(20) NULL COMMENT '手机号',
    `email` VARCHAR(100) NULL COMMENT '邮箱',
    `avatar` VARCHAR(255) NULL COMMENT '头像URL',
    `status` TINYINT NOT NULL DEFAULT 0 COMMENT '账号状态：0-启用，1-禁用',
    `create_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `update_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    `create_by` BIGINT NULL COMMENT '创建人',
    `update_by` BIGINT NULL COMMENT '更新人',
    `is_deleted` TINYINT NOT NULL DEFAULT 0 COMMENT '逻辑删除：0-未删除，1-已删除',
    PRIMARY KEY (`id`),
    UNIQUE KEY `uk_username` (`username`),
    KEY `idx_status` (`status`),
    KEY `idx_is_deleted` (`is_deleted`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='用户表';
```

**规范要点**：
- 使用 BIGINT 作为主键类型（支持雪花算法）
- 所有表包含 BaseEntity 的基础字段
- 合理添加注释
- 必要字段添加索引
- 使用 utf8mb4 字符集

#### 2. 测试数据规范

```sql
-- 角色数据
INSERT INTO `sys_role` VALUES
(1, 'ADMIN', '系统管理员', 0, NOW(), NOW(), NULL, NULL, 0),
(2, 'USER', '普通用户', 0, NOW(), NOW(), NULL, NULL, 0),
(3, 'GUEST', '访客', 0, NOW(), NOW(), NULL, NULL, 0);

-- 用户数据（密码使用 BCrypt 加密）
INSERT INTO `sys_user` VALUES
(1001, 'admin', '$2a$10$N.zmdr9k7uOCQb376NoUnuTJ8iAt6Z5EHsM8MYdLn2z/6N8uPHVqK', 
 '系统管理员', '13800138001', 'admin@example.com', NULL, 0, NOW(), NOW(), NULL, NULL, 0);

-- 用户角色关联
INSERT INTO `sys_user_role` VALUES
(2001, 1001, 1, NOW(), NOW(), NULL, NULL, 0);
```

### 单元测试规范

#### 1. Service 层测试

```java
@ExtendWith(MockitoExtension.class)
class AuthServiceTest {
    
    @Mock
    private RedisTemplate<String, Object> redisTemplate;
    
    @Mock
    private UserService userService;
    
    @Mock
    private PasswordEncoder passwordEncoder;
    
    @InjectMocks
    private AuthServiceImpl authService;
    
    @BeforeEach
    void setUp() {
        ReflectionTestUtils.setField(authService, "tokenKeyPrefix", "token:");
        ReflectionTestUtils.setField(authService, "tokenTtlSeconds", 86400L);
    }
    
    @Test
    void testLoginSuccess() {
        // 准备测试数据
        AuthRequests.LoginRequest request = new AuthRequests.LoginRequest();
        request.setUsername("admin");
        request.setPassword("admin123");
        
        User user = new User();
        user.setId(1001L);
        user.setUsername("admin");
        user.setPassword("$2a$10$encodedPassword");
        user.setStatus(0);
        user.setRoles(Arrays.asList("ADMIN", "USER"));
        
        // Mock 行为
        when(userService.getByUsername("admin")).thenReturn(user);
        when(passwordEncoder.matches("admin123", "$2a$10$encodedPassword")).thenReturn(true);
        
        // 执行测试
        String token = authService.login(request);
        
        // 验证结果
        assertNotNull(token);
        assertFalse(token.isEmpty());
        verify(valueOperations, times(2)).set(anyString(), any(), anyLong(), any());
    }
}
```

### 最佳实践总结（阶段三）

#### 1. 安全性最佳实践

- ✅ 使用 BCrypt 加密密码（不可逆）
- ✅ 使用 ECC 加密敏感数据（可逆）
- ✅ Token 存储在 Redis 而不是 JWT（支持强制下线）
- ✅ 实现滑动过期机制（提升用户体验）
- ✅ 实现单点登录/互踢机制（安全性）
- ✅ 实现白名单机制（精确控制开放接口）
- ✅ 密钥从配置文件或环境变量读取（不硬编码）

#### 2. 架构设计最佳实践

- ✅ 双 Key 结构设计（支持多种查询场景）
- ✅ 无状态会话管理（支持分布式部署）
- ✅ 异常处理器统一返回格式（API 一致性）
- ✅ 角色权限分离设计（灵活的权限管理）
- ✅ 方法级权限控制（@PreAuthorize）

#### 3. 开发效率提升

- ✅ MyBatis-Plus 自动加解密（EncryptedTypeHandler）
- ✅ Spring Security 统一认证流程
- ✅ 完善的单元测试（Mock 框架）
- ✅ 完整的数据库脚本（快速初始化）

---

## 🚨 异常处理规范（阶段四）

### 异常分类原则

#### 1. 预期异常（Checked Exceptions）
- **定义**: 业务逻辑中可预期的、正常的错误情况
- **处理方式**: 记录 WARN 日志，返回错误码，不记录堆栈信息
- **示例**: 参数校验失败、用户不存在、密码错误、权限不足

#### 2. 非预期异常（Unchecked Exceptions）
- **定义**: 程序运行时出现的技术故障
- **处理方式**: 记录 ERROR 日志，记录完整堆栈，返回 500 错误
- **示例**: 数据库连接失败、空指针异常、除零异常

### 业务异常类 (BusinessException)

#### 定义规范

```java
package com.dawnmoon.springboot_app_template.common.exception;

import com.dawnmoon.springboot_app_template.common.enums.ErrorCode;
import lombok.Getter;

/**
 * 业务异常
 * 用于业务逻辑中的可预期异常，不记录堆栈跟踪
 */
@Getter
public class BusinessException extends RuntimeException {

    private final ErrorCode errorCode;
    private final String message;

    /**
     * 构造业务异常（使用错误码）
     */
    public BusinessException(ErrorCode errorCode) {
        super(errorCode.getDescription());
        this.errorCode = errorCode;
        this.message = errorCode.getDescription();
    }

    /**
     * 构造业务异常（使用错误码和自定义消息）
     */
    public BusinessException(ErrorCode errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
        this.message = message;
    }

    /**
     * 构造业务异常（仅使用自定义消息）
     */
    public BusinessException(String message) {
        super(message);
        this.errorCode = ErrorCode.BUSINESS_ERROR;
        this.message = message;
    }
}
```

#### 使用规范

```java
// ✅ 正确示例 1: 使用错误码
if (user == null) {
    throw new BusinessException(ErrorCode.USER_NOT_FOUND);
}

// ✅ 正确示例 2: 使用错误码 + 自定义消息
if (user == null) {
    throw new BusinessException(ErrorCode.USER_NOT_FOUND, "用户ID: " + userId + " 不存在");
}

// ✅ 正确示例 3: 使用自定义消息
if (balance < amount) {
    throw new BusinessException("余额不足，当前余额: " + balance);
}

// ❌ 错误示例: 不要用于系统异常
try {
    database.connect();
} catch (SQLException e) {
    // ❌ 错误：应该让异常向上抛出，由 GlobalExceptionHandler 统一处理
    throw new BusinessException("数据库连接失败");
}
```

### 全局异常处理器 (GlobalExceptionHandler)

#### 定义规范

```java
package com.dawnmoon.springboot_app_template.common.exception;

import com.dawnmoon.springboot_app_template.common.api.ApiResponse;
import com.dawnmoon.springboot_app_template.common.enums.ErrorCode;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;

/**
 * 全局异常处理器
 * 统一处理应用中的所有异常，并返回标准化的错误响应
 */
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    // 预期异常：返回 200 状态码 + 错误码
    @ExceptionHandler(BusinessException.class)
    @ResponseStatus(HttpStatus.OK)
    public ApiResponse<Void> handleBusinessException(BusinessException e) {
        log.warn("业务异常: [{}] {}", e.getErrorCode().getCode(), e.getMessage());
        return ApiResponse.error(e.getErrorCode(), e.getMessage());
    }

    // 非预期异常：返回 500 状态码 + 完整堆栈
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ApiResponse<Void> handleException(Exception e) {
        log.error("系统异常", e);  // 记录完整堆栈
        return ApiResponse.error(ErrorCode.INTERNAL_SERVER_ERROR, "系统繁忙，请稍后再试");
    }
}
```

#### 支持的异常类型

| 异常类型 | HTTP状态码 | 日志级别 | 堆栈跟踪 | 说明 |
|---------|----------|---------|---------|------|
| `BusinessException` | 200 | WARN | 否 | 业务异常 |
| `MethodArgumentNotValidException` | 200 | WARN | 否 | @Valid 参数校验异常 |
| `BindException` | 200 | WARN | 否 | @Validated 参数绑定异常 |
| `ConstraintViolationException` | 200 | WARN | 否 | 约束违反异常 |
| `BadCredentialsException` | 200 | WARN | 否 | 认证失败异常 |
| `AccessDeniedException` | 200 | WARN | 否 | 权限不足异常 |
| `Exception` | 500 | ERROR | 是 | 所有未捕获的异常 |

### 异常处理最佳实践

#### 1. Controller 层

```java
@RestController
@RequestMapping("/api/user")
@RequiredArgsConstructor
public class UserController {
    
    private final UserService userService;
    
    /**
     * ✅ 正确示例：不捕获异常，让 GlobalExceptionHandler 统一处理
     */
    @GetMapping("/{id}")
    public ApiResponse<User> getById(@PathVariable Long id) {
        User user = userService.getById(id);
        return ApiResponse.success(user);
    }
    
    /**
     * ❌ 错误示例：不要在 Controller 中 try-catch
     */
    @GetMapping("/{id}/bad")
    public ApiResponse<User> getByIdBad(@PathVariable Long id) {
        try {
            User user = userService.getById(id);
            return ApiResponse.success(user);
        } catch (BusinessException e) {
            // ❌ 不要这样做，GlobalExceptionHandler 会自动处理
            return ApiResponse.error(e.getErrorCode(), e.getMessage());
        }
    }
}
```

#### 2. Service 层

```java
@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {
    
    private final UserMapper userMapper;
    
    /**
     * ✅ 正确示例：抛出业务异常
     */
    @Override
    public User getById(Long id) {
        User user = userMapper.selectById(id);
        if (user == null) {
            throw new BusinessException(ErrorCode.USER_NOT_FOUND);
        }
        return user;
    }
    
    /**
     * ✅ 正确示例：系统异常不捕获，向上抛出
     */
    @Override
    public void updateUser(User user) {
        // 如果数据库操作失败，会抛出 SQLException 等系统异常
        // 不要捕获，让 GlobalExceptionHandler 统一处理
        userMapper.updateById(user);
    }
    
    /**
     * ❌ 错误示例：不要返回 null
     */
    @Override
    public User getByIdBad(Long id) {
        User user = userMapper.selectById(id);
        // ❌ 不要返回 null，应该抛出异常
        return user;
    }
}
```

#### 3. 参数校验

```java
/**
 * ✅ 正确示例：使用 @Valid 注解自动校验
 */
@PostMapping
public ApiResponse<Void> create(@RequestBody @Valid UserCreateRequest request) {
    // 如果校验失败，会自动抛出 MethodArgumentNotValidException
    // GlobalExceptionHandler 会捕获并返回错误码
    userService.create(request);
    return ApiResponse.success();
}

// 请求对象定义
@Data
public class UserCreateRequest {
    
    @NotBlank(message = "用户名不能为空")
    @Size(min = 3, max = 20, message = "用户名长度必须在3-20之间")
    private String username;
    
    @NotBlank(message = "密码不能为空")
    @Size(min = 6, max = 20, message = "密码长度必须在6-20之间")
    private String password;
    
    @Email(message = "邮箱格式不正确")
    private String email;
}
```

---

## 📊 日志追踪规范（阶段四）

### MDC 链路追踪原理

MDC（Mapped Diagnostic Context）是 SLF4J 提供的日志上下文机制：
- 在请求开始时将 traceId 放入 MDC
- 当前线程的所有日志都会包含这个 traceId
- 在请求结束时清理 MDC，避免内存泄漏

### TraceId 过滤器 (TraceIdFilter)

#### 定义规范

```java
package com.dawnmoon.springboot_app_template.common.log;

import jakarta.servlet.*;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.MDC;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.UUID;

/**
 * TraceId 过滤器
 * 为每个HTTP请求生成唯一的traceId，用于链路追踪
 */
@Slf4j
@Component
@Order(1)  // 确保该过滤器优先执行
public class TraceIdFilter implements Filter {

    private static final String TRACE_ID = "traceId";
    private static final String TRACE_ID_HEADER = "X-Trace-Id";

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {

        HttpServletRequest httpRequest = (HttpServletRequest) request;

        // 1. 从请求头获取 traceId，如果不存在则生成新的
        String traceId = httpRequest.getHeader(TRACE_ID_HEADER);
        if (traceId == null || traceId.isEmpty()) {
            traceId = generateTraceId();
        }

        // 2. 设置到 MDC，后续所有日志都会包含这个 traceId
        MDC.put(TRACE_ID, traceId);

        // 3. 记录请求开始时间
        long startTime = System.currentTimeMillis();

        try {
            // 4. 执行请求链
            chain.doFilter(request, response);
        } finally {
            // 5. 计算请求耗时
            long duration = System.currentTimeMillis() - startTime;

            // 6. 记录请求日志（包含方法、URI、耗时）
            String queryString = httpRequest.getQueryString();
            log.info("请求完成: {} {} {} - 耗时: {}ms",
                    httpRequest.getMethod(),
                    httpRequest.getRequestURI(),
                    queryString != null ? "?" + queryString : "",
                    duration);

            // 7. 清除 MDC，避免内存泄漏（特别是在使用线程池的情况下）
            MDC.remove(TRACE_ID);
        }
    }

    /**
     * 生成唯一的 TraceId
     */
    private String generateTraceId() {
        return UUID.randomUUID().toString().replace("-", "");
    }
}
```

### Logback 配置规范

#### 日志文件命名规则

按照用户需求，日志文件名格式为：`年-月-日-时-分-秒.log`，每次程序启动创建新文件。

#### logback-spring.xml 配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    
    <!-- 从application.yaml读取日志路径配置 -->
    <springProperty scope="context" name="LOG_PATH" source="logging.file.path" defaultValue="logs"/>
    
    <!-- 日志格式定义 -->
    <property name="LOG_PATTERN"
              value="[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%thread] [%-5level] [%X{traceId}] %logger{36} - %msg%n"/>

    <!-- 控制台输出配置 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>${LOG_PATTERN}</pattern>
            <charset>UTF-8</charset>
        </encoder>
    </appender>

    <!-- 文件输出配置 - 所有日志 -->
    <!-- 使用timestamp生成启动时的时间戳，作为文件名 -->
    <timestamp key="startTime" datePattern="yyyy-MM-dd-HH-mm-ss"/>
    
    <appender name="FILE_ALL" class="ch.qos.logback.core.FileAppender">
        <file>${LOG_PATH}/${startTime}.log</file>
        <encoder>
            <pattern>${LOG_PATTERN}</pattern>
            <charset>UTF-8</charset>
        </encoder>
        <append>true</append>
    </appender>

    <!-- 文件输出配置 - 错误日志 -->
    <appender name="FILE_ERROR" class="ch.qos.logback.core.FileAppender">
        <file>${LOG_PATH}/${startTime}-error.log</file>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>ERROR</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
        <encoder>
            <pattern>${LOG_PATTERN}</pattern>
            <charset>UTF-8</charset>
        </encoder>
        <append>true</append>
    </appender>

    <!-- 根日志级别配置 -->
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE_ALL"/>
        <appender-ref ref="FILE_ERROR"/>
    </root>

    <!-- 项目日志级别配置 -->
    <logger name="com.dawnmoon.springboot_app_template" level="DEBUG" additivity="false">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE_ALL"/>
        <appender-ref ref="FILE_ERROR"/>
    </logger>
</configuration>
```

#### application.yaml 配置

```yaml
# 日志配置
logging:
  # 日志文件路径
  file:
    path: logs
```

### 日志使用规范

#### 1. 日志级别使用标准

| 级别 | 使用场景 | 示例 |
|-----|---------|------|
| **ERROR** | 系统错误、未捕获异常 | `log.error("系统异常", e)` |
| **WARN** | 业务异常、预期错误 | `log.warn("用户不存在: {}", userId)` |
| **INFO** | 重要业务流程、状态变更 | `log.info("用户登录成功: {}", username)` |
| **DEBUG** | 调试信息、详细流程 | `log.debug("查询参数: {}", params)` |
| **TRACE** | 非常详细的调试信息 | `log.trace("方法执行: {}", methodName)` |

#### 2. 日志输出最佳实践

```java
@Service
@RequiredArgsConstructor
@Slf4j  // Lombok 注解，自动生成 log 对象
public class UserServiceImpl implements UserService {
    
    /**
     * ✅ 正确示例：使用占位符
     */
    @Override
    public User login(String username, String password) {
        log.info("用户登录请求: username={}", username);  // ✅ 使用占位符
        
        User user = userMapper.selectByUsername(username);
        if (user == null) {
            log.warn("用户不存在: {}", username);  // ✅ WARN 级别
            throw new BusinessException(ErrorCode.USER_NOT_FOUND);
        }
        
        if (!passwordEncoder.matches(password, user.getPassword())) {
            log.warn("密码错误: username={}", username);  // ✅ 不记录密码
            throw new BusinessException(ErrorCode.USERNAME_OR_PASSWORD_ERROR);
        }
        
        log.info("用户登录成功: userId={}, username={}", user.getId(), username);
        return user;
    }
    
    /**
     * ❌ 错误示例：不要使用字符串拼接
     */
    @Override
    public User loginBad(String username, String password) {
        // ❌ 字符串拼接会消耗性能，即使日志级别不够也会执行拼接
        log.info("用户登录请求: username=" + username);
        
        // ❌ 不要记录敏感信息（密码、身份证号等）
        log.info("用户登录: username={}, password={}", username, password);
        
        return null;
    }
}
```

#### 3. 异常日志规范

```java
/**
 * ✅ 正确示例：记录完整异常堆栈
 */
try {
    riskyOperation();
} catch (Exception e) {
    // ✅ 记录完整堆栈信息
    log.error("操作失败: {}", e.getMessage(), e);
    throw e;
}

/**
 * ❌ 错误示例：只记录异常消息
 */
try {
    riskyOperation();
} catch (Exception e) {
    // ❌ 没有记录堆栈信息，无法定位问题
    log.error("操作失败: {}", e.getMessage());
    throw e;
}
```

### 日志文件管理

#### 日志文件结构

```
logs/
├── 2025-10-22-10-30-00.log        # 普通日志
├── 2025-10-22-10-30-00-error.log  # 错误日志
├── 2025-10-22-14-15-30.log        # 下次启动的日志
└── 2025-10-22-14-15-30-error.log  # 下次启动的错误日志
```

#### 日志清理策略

建议定期清理日志文件，避免磁盘空间占满：

```bash
# 保留最近 7 天的日志
find logs/ -name "*.log" -mtime +7 -delete

# 或使用 cron 定时任务
0 2 * * * find /path/to/logs/ -name "*.log" -mtime +7 -delete
```

### 链路追踪使用场景

#### 1. 分布式追踪

```java
// 微服务间传递 traceId
RestTemplate restTemplate = new RestTemplate();
HttpHeaders headers = new HttpHeaders();
headers.set("X-Trace-Id", MDC.get("traceId"));

HttpEntity<String> entity = new HttpEntity<>(headers);
restTemplate.exchange(url, HttpMethod.GET, entity, String.class);
```

#### 2. 日志查询

```bash
# 根据 traceId 查询完整请求链路
grep "abc123def456" logs/2025-10-22-10-30-00.log
```

#### 3. 日志格式示例

```
[2025-10-22 10:30:15.123] [http-nio-8080-exec-1] [INFO ] [abc123def456] c.d.s.c.AuthController - 用户登录请求: username=admin
[2025-10-22 10:30:15.234] [http-nio-8080-exec-1] [DEBUG] [abc123def456] c.d.s.s.i.UserServiceImpl - 查询用户: username=admin
[2025-10-22 10:30:15.345] [http-nio-8080-exec-1] [INFO ] [abc123def456] c.d.s.s.i.AuthServiceImpl - 用户登录成功: userId=1001
[2025-10-22 10:30:15.456] [http-nio-8080-exec-1] [INFO ] [abc123def456] c.d.s.c.l.TraceIdFilter - 请求完成: POST /api/auth/login  - 耗时: 333ms
```

### 最佳实践总结（阶段四）

#### 1. 异常处理最佳实践

- ✅ 使用 BusinessException 处理业务异常
- ✅ 不在 Controller 中 try-catch，让 GlobalExceptionHandler 统一处理
- ✅ 预期异常记录 WARN 日志，非预期异常记录 ERROR 日志
- ✅ 使用 @Valid 和 @Validated 进行参数校验
- ✅ 异常消息清晰明确，便于定位问题

#### 2. 日志追踪最佳实践

- ✅ 使用 MDC 实现链路追踪
- ✅ 每个请求自动生成唯一 traceId
- ✅ 日志格式统一，包含时间、线程、级别、traceId、logger、消息
- ✅ 日志文件按启动时间命名，便于定位问题
- ✅ 记录请求耗时，便于性能分析

#### 3. 开发效率提升

- ✅ 全局异常处理器统一返回格式
- ✅ TraceId 过滤器自动生成链路追踪ID
- ✅ Logback 配置灵活，支持多种输出方式
- ✅ 测试脚本 test_phase4.ps1 快速验证功能

---