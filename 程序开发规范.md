# SpringBoot 应用模板 - 程序开发规范

> 基于 Spring Boot 3.5.6 + MyBatis-Plus 3.5.9 + Spring Security 6.x 的企业级应用开发规范（完整版）

---

## 文档概述

本文档是 SpringBoot 应用模板的开发规范指南，定义了基于此模板进行项目开发的标准流程、代码规范、最佳实践和使用方法。

---

## 项目架构规范

### 分层架构标准

项目采用经典的分层架构模式，各层职责明确：

```
┌─────────────────────────────────────┐
│        Controller Layer             │  ← REST API 接口层
│        (@RestController)            │
├─────────────────────────────────────┤
│        Service Layer                │  ← 业务逻辑层
│        (@Service)                   │
├─────────────────────────────────────┤
│        Mapper Layer                 │  ← 数据访问层
│        (@Mapper)                    │
├─────────────────────────────────────┤
│        Entity Layer                 │  ← 实体模型层
│        (BaseEntity)                 │
├─────────────────────────────────────┤
│        Common Layer                 │  ← 通用组件层
│        (Utils, Enums, Config)       │
└─────────────────────────────────────┘
```

### 包结构规范

```
src/main/java/com/dawnmoon/springboot_app_template/
├── SpringbootAppTemplateApplication.java    # 主启动类
├── controller/                              # 控制器层
│   ├── AuthController.java                 # 认证控制器
│   └── UserController.java                 # 用户管理控制器
├── service/                                # 服务层
│   ├── AuthService.java                   # 认证服务接口
│   ├── UserService.java                   # 用户服务接口
│   └── serviceImpl/                       # 服务实现
│       ├── AuthServiceImpl.java           # 认证服务实现
│       └── UserServiceImpl.java           # 用户服务实现
├── mapper/                                 # 数据访问层
│   ├── UserMapper.java                    # 用户Mapper接口
│   ├── RoleMapper.java                    # 角色Mapper接口
│   └── UserRoleMapper.java                # 用户角色关联Mapper
├── model/                                  # 模型层
│   ├── entity/                            # 实体类
│   │   ├── BaseEntity.java               # 基础实体类
│   │   ├── User.java                     # 用户实体
│   │   ├── Role.java                     # 角色实体
│   │   └── UserRole.java                 # 用户角色关联实体
│   ├── request/                          # 请求参数对象
│   │   ├── AuthRequests.java            # 认证请求
│   │   └── UserRequests.java            # 用户请求
│   └── response/                         # 响应对象
│       ├── PageResponse.java            # 分页响应
│       └── UserResponse.java            # 用户响应
├── common/                                 # 通用组件
│   ├── api/                              # API相关
│   │   └── ApiResponse.java             # 统一返回体
│   ├── enums/                            # 枚举类
│   │   ├── BaseEnum.java                # 枚举基础接口
│   │   └── ErrorCode.java               # 错误码枚举
│   ├── exception/                        # 异常处理
│   │   ├── BusinessException.java       # 业务异常
│   │   └── GlobalExceptionHandler.java  # 全局异常处理器
│   ├── log/                              # 日志组件
│   │   └── TraceIdFilter.java           # 链路追踪过滤器
│   └── security/                         # 安全组件
│       ├── SecurityUtil.java            # 安全工具类
│       ├── UserPrincipal.java           # 用户认证主体
│       ├── JwtAuthenticationFilter.java # JWT认证过滤器
│       ├── RestAuthenticationEntryPoint.java    # 未认证处理器
│       ├── RestAccessDeniedHandler.java         # 权限不足处理器
│       ├── EncryptedField.java          # 加密字段注解
│       └── EncryptedTypeHandler.java    # 加密字段处理器
├── config/                                # 配置类
│   ├── MybatisPlusConfig.java           # MyBatis-Plus配置
│   ├── RedisConfig.java                 # Redis配置
│   ├── SecurityConfig.java              # Spring Security配置
│   └── Knife4jConfig.java               # Knife4j配置 
└── util/                                  # 工具类
    ├── PageUtil.java                     # 分页工具类
    └── CryptoUtil.java                   # 加密工具类
```

---

## 代码编写规范

### 实体类规范

#### 1. 基础实体类

所有实体类必须继承 `BaseEntity`，它提供了通用的基础字段：

```java
@Data
public abstract class BaseEntity implements Serializable {
    
    /**
     * 主键ID - 使用雪花算法自动生成
     * @TableId: MyBatis-Plus主键注解
     * - value: 数据库字段名
     * - type: 主键生成策略，ASSIGN_ID使用雪花算法
     */
    @TableId(value = "id", type = IdType.ASSIGN_ID)
    private Long id;

    /**
     * 创建时间 - 插入时自动填充
     * @TableField: MyBatis-Plus字段注解
     * - value: 数据库字段名
     * - fill: 自动填充策略，INSERT表示插入时填充
     */
    @TableField(value = "create_at", fill = FieldFill.INSERT)
    private LocalDateTime createAt;

    /**
     * 更新时间 - 插入和更新时自动填充
     * - fill: INSERT_UPDATE表示插入和更新时都填充
     */
    @TableField(value = "update_at", fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateAt;

    /**
     * 创建人 - 插入时自动填充
     */
    @TableField(value = "create_by", fill = FieldFill.INSERT)
    private Long createBy;

    /**
     * 更新人 - 插入和更新时自动填充
     */
    @TableField(value = "update_by", fill = FieldFill.INSERT_UPDATE)
    private Long updateBy;

    /**
     * 逻辑删除标识 - 0: 未删除, 1: 已删除
     * @TableLogic: MyBatis-Plus逻辑删除注解
     * - value: 未删除时的值
     * - delval: 删除时的值
     */
    @TableLogic(value = "0", delval = "1")
    @TableField("is_deleted")
    private Integer isDeleted;
}
```

#### 2. 业务实体类

```java
/**
 * 用户实体类
 * @Data: Lombok注解，生成getter/setter等方法
 * @EqualsAndHashCode(callSuper = true): 生成equals和hashCode时包含父类字段
 * @TableName: 指定数据库表名
 */
@Data
@EqualsAndHashCode(callSuper = true)
@TableName("sys_user")
public class User extends BaseEntity {

    /**
     * 用户名
     * @TableField: 指定数据库字段名
     */
    @TableField("username")
    private String username;

    /**
     * 密码（BCrypt加密）
     */
    @TableField("password")
    private String password;

    /**
     * 真实姓名
     */
    @TableField("real_name")
    private String realName;

    /**
     * 手机号
     */
    @TableField("phone")
    private String phone;

    /**
     * 邮箱
     */
    @TableField("email")
    private String email;

    /**
     * 头像URL
     */
    @TableField("avatar")
    private String avatar;

    /**
     * 账号状态：0-启用，1-禁用
     */
    @TableField("status")
    private Integer status;

    /**
     * 用户角色列表（不存储在数据库中，通过关联查询获取）
     * @TableField(exist = false): 表示该字段不对应数据库字段
     */
    @TableField(exist = false)
    private List<String> roles;
}
```

### Controller 层规范

#### 1. 基础注解配置

```java
/**
 * 认证授权 Controller
 * @Tag: Swagger文档注解，定义接口分组
 * @RestController: Spring MVC注解，标识REST控制器，自动将返回值序列化为JSON
 * @RequestMapping: 定义控制器的基础路径
 * @RequiredArgsConstructor: Lombok注解，为final字段生成构造函数
 * @Validated: 启用方法级别的参数校验
 */
@Tag(name = "认证授权", description = "登录、注册相关接口")
@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
@Validated
public class AuthController {
    // Controller实现
}
```

#### 2. 接口方法规范

```java
/**
 * @Operation: Swagger文档注解，描述接口功能
 * @PostMapping: Spring MVC注解，处理POST请求
 * @RequestBody: 将请求体JSON转换为Java对象
 * @Valid: 启用Bean Validation校验
 */
@Operation(summary = "用户登录", description = "验证用户名密码，返回 Token")
@PostMapping("/login")
public ApiResponse<String> login(@RequestBody @Valid AuthRequests.LoginRequest request) {
    // TODO: 实现登录逻辑
    return ApiResponse.success("mock-token-12345");
}
```

#### 3. 统一返回格式

所有接口必须使用 `ApiResponse` 统一返回格式：

```java
// 成功响应（无数据）
return ApiResponse.success();

// 成功响应（带数据）
return ApiResponse.success(data);

// 成功响应（自定义消息）
return ApiResponse.success("操作成功", data);

// 失败响应
return ApiResponse.error(ErrorCode.USER_NOT_FOUND);
return ApiResponse.error(ErrorCode.USER_NOT_FOUND, message)
return ApiResponse.error(ErrorCode.USER_NOT_FOUND, message, data);
```

### Service 层规范

#### 1. 接口和实现分离

```java
// 服务接口
public interface UserService {
    User getByUsername(String username);
    User getById(Long id);
    void create(User user);
    void update(User user);
    void delete(Long id);
    PageResponse<User> list(Integer pageNum, Integer pageSize, String keyword);
}
```

#### 2. 服务实现类

```java
/**
 * 用户服务实现类
 * @Service: Spring注解，标识服务层组件
 * @RequiredArgsConstructor: Lombok注解，为final字段生成构造函数
 * @Transactional(readOnly = true): 类级别事务，默认只读事务
 */
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class UserServiceImpl implements UserService {

   private final UserMapper userMapper;

   @Override
   public User getByUsername(String username) {
      return userMapper.selectByUsername(username);
   }

   @Override
   public User getById(Long id) {
      return userMapper.selectById(id);
   }

   @Override
   @Transactional(rollbackFor = Exception.class)
   public void create(User user) {
      userMapper.insert(user);
   }

   @Override
   @Transactional(rollbackFor = Exception.class)
   public void update(User user) {
      userMapper.updateById(user);
   }

   @Override
   @Transactional(rollbackFor = Exception.class)
   public void delete(Long id) {
      userMapper.deleteById(id);
   }

   @Override
   public PageResponse<User> list(Integer pageNum, Integer pageSize, String keyword) {
      // 使用 MyBatis-Plus 分页
      IPage<User> page = userMapper.selectUsersByKeyword(new Page<>(pageNum, pageSize), keyword);
      return PageUtil.toPageResponse(page);
   }
}
```

**关键注解说明**:
- `@Service`: 标识服务层组件，Spring会自动扫描并注册为Bean
- `@Transactional`: 声明式事务管理
  - `readOnly = true`: 只读事务，优化性能
  - `rollbackFor = Exception.class`: 遇到任何异常都回滚

默认情况下，只有当事务中的代码抛出Unchecked Exceptions时才会回滚（如 NullPointerException, IllegalArgumentException），而Checked Exceptions（如 IOException, SQLException）不会回滚。

使用`@Transactional(rollbackFor = Exception.class)`可以保证除了默认的 RuntimeException 和 Error，当方法抛出任何 Exception 及其子类的实例时，都回滚当前事务.

**注意**：严禁在ServiceImpl中使用queryWrapper，所有sql操作都必须在mapper层中实现，简单的可以通过注解写sql语句，复杂的在xml中写sql语句。

### Mapper 层规范

#### 1. Mapper接口定义

```java
/**
 * 用户 Mapper 接口
 * @Mapper: MyBatis注解，标识Mapper接口
 * extends BaseMapper<User>: 继承MyBatis-Plus基础Mapper，获得基本CRUD方法
 */
@Mapper
public interface UserMapper extends BaseMapper<User> {

   /**
    * 根据用户名查询用户 - 简单查询，使用注解
    */
   @Select("SELECT * FROM sys_user WHERE username = #{username} AND is_deleted = 0")
   User selectByUsername(@Param("username") String username);

   /**
    * 根据手机号查询用户 - 简单查询，使用注解
    */
   @Select("SELECT * FROM sys_user WHERE phone = #{phone} AND is_deleted = 0")
   User selectByPhone(@Param("phone") String phone);

   /**
    * 根据邮箱查询用户 - 简单查询，使用注解
    */
   @Select("SELECT * FROM sys_user WHERE email = #{email} AND is_deleted = 0")
   User selectByEmail(@Param("email") String email);

   /**
    * 根据关键词分页查询用户列表 - 复杂查询，使用XML实现
    */
   List<User> selectUsersByKeyword(@Param("keyword") String keyword);
}

```

**关键注解说明**:
- `@Mapper`: 标识MyBatis Mapper接口，Spring会自动创建代理实现
- `@Param`: 为方法参数指定名称，在XML映射文件中使用

#### 2. 查询策略规范

**重要**: 本项目采用分层查询策略，禁止在 Service 层使用 QueryWrapper 或 LambdaQueryWrapper。

**查询策略**:
1. **简单查询**：使用 `@Select` 注解直接在 Mapper 接口中定义 SQL
2. **复杂查询**：使用 XML 映射文件定义 SQL（动态条件、多表JOIN等）

**示例**:
```java
// 简单查询 - 使用注解
@Select("SELECT * FROM sys_user WHERE username = #{username} AND is_deleted = 0")
User selectByUsername(@Param("username") String username);

// 复杂查询 - 使用XML（动态模糊查询）
List<User> selectUsersByKeyword(@Param("keyword") String keyword);
```

**XML映射文件规范** (仅用于复杂查询):

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.dawnmoon.charon.mapper.UserMapper">

    <!-- 只包含复杂的查询逻辑（动态条件、多表JOIN等） -->
    <!-- 简单查询直接在Mapper接口中使用 @Select 注解定义 -->

    <!-- 根据关键词分页查询用户列表 - 复杂查询，使用XML实现 -->
    <select id="selectUsersByKeyword" resultType="com.dawnmoon.charon.model.entity.User">
        SELECT * FROM sys_user
        WHERE is_deleted = 0
        <if test="keyword != null and keyword != ''">
            AND (
            username LIKE CONCAT('%', #{keyword}, '%')
            OR real_name LIKE CONCAT('%', #{keyword}, '%')
            OR phone LIKE CONCAT('%', #{keyword}, '%')
            OR email LIKE CONCAT('%', #{keyword}, '%')
            )
        </if>
        ORDER BY create_at DESC
    </select>

</mapper>
```

**XML映射规范**:
- 文件名必须与 Mapper 接口名一致：`UserMapper.xml`
- namespace 必须与 Mapper 接口全限定名一致
- 只包含复杂的查询逻辑，简单查询使用注解
- 所有查询必须包含 `AND is_deleted = 0`（逻辑删除条件）
- 使用 `<if>` 标签进行条件判断，避免动态拼接
- 使用 CONCAT 函数进行模糊查询

---

## 📊 数据访问规范

### MyBatis-Plus 配置

#### 1. 配置类 (MybatisPlusConfig)

```java
/**
 * MyBatis-Plus 配置类
 * @Configuration: Spring配置类注解
 * @MapperScan: 指定Mapper接口扫描包路径
 */
@Configuration
@MapperScan("com.dawnmoon.charonclass MybatisPlusConfig {

    /**
     * 自动填充处理器
     * @Slf4j: Lombok注解，自动生成log字段
     * @Component: Spring组件注解，注册为Bean
     */
    @Slf4j
    @Component
    public static class MyMetaObjectHandler implements MetaObjectHandler {

        @Override
        public void insertFill(MetaObject metaObject) {
            log.debug("开始插入填充...");

            // 填充创建时间和更新时间
            this.strictInsertFill(metaObject, "createAt", LocalDateTime.class, LocalDateTime.now());
            this.strictInsertFill(metaObject, "updateAt", LocalDateTime.class, LocalDateTime.now());

            // 填充创建人和更新人（从当前登录用户获取）
            Long currentUserId = SecurityUtil.getCurrentUserId();
            if (currentUserId != null) {
                this.strictInsertFill(metaObject, "createBy", Long.class, currentUserId);
                this.strictInsertFill(metaObject, "updateBy", Long.class, currentUserId);
            }
        }

        @Override
        public void updateFill(MetaObject metaObject) {
            log.debug("开始更新填充...");

            // 填充更新时间和更新人
            this.strictUpdateFill(metaObject, "updateAt", LocalDateTime.class, LocalDateTime.now());

            Long currentUserId = SecurityUtil.getCurrentUserId();
            if (currentUserId != null) {
                this.strictUpdateFill(metaObject, "updateBy", Long.class, currentUserId);
            }
        }
    }
}
```

**关键接口说明**:
- `MetaObjectHandler`: MyBatis-Plus自动填充处理器接口
- `strictInsertFill()`: 严格模式插入填充，只有字段为null时才填充
- `strictUpdateFill()`: 严格模式更新填充

#### 2. 分页查询规范

**重要**: 禁止使用 MyBatis-Plus 的 QueryWrapper 或 LambdaQueryWrapper 进行动态查询。所有数据库查询必须通过 Mapper
接口中定义的注解 SQL 或 XML 映射文件实现。

**替代方案**:
1. 在 Mapper 接口中定义自定义查询方法
2. 在 XML 映射文件中编写对应的 SQL 语句
3. 在 Service 中调用自定义的 Mapper 方法

```java
// 使用 MyBatis-Plus 进行分页
public PageResponse<User> list(Integer pageNum, Integer pageSize, String keyword) {
    IPage<User> page = userMapper.selectUsersByKeyword(new Page<>(pageNum, pageSize), keyword);
    return PageUtil.toPageResponse(page);
}
```

**分页工具类 (PageUtil)**:

```java
/**
 * 分页工具类
 * 提供 IPage 到 PageResponse 的转换方法
 */
public class PageUtil {

    /**
     * 将 IPage 转换为 PageResponse
     */
    public static <T> PageResponse<T> toPageResponse(IPage<T> page) {
        PageResponse<T> response = new PageResponse<>();
        response.setTotal(page.getTotal());
        response.setPageNum((int) page.getCurrent());
        response.setPageSize((int) page.getSize());
        response.setPages((int) page.getPages());
        response.setList(page.getRecords());
        return response;
    }

    /**
     * 将 IPage 转换为 PageResponse，并对列表进行转换
     * 用于Entity到VO的转换
     */
    public static <S, T> PageResponse<T> toPageResponse(IPage<S> page, Function<S, T> converter) {
        PageResponse<T> response = new PageResponse<>();
        response.setTotal(page.getTotal());
        response.setPageNum((int) page.getCurrent());
        response.setPageSize((int) page.getSize());
        response.setPages((int) page.getPages());

        List<T> convertedList = page.getRecords().stream()
                .map(converter)
                .collect(Collectors.toList());
        response.setList(convertedList);

        return response;
    }
}
```

---

## API 设计规范

### 统一返回体 (ApiResponse)

#### 1. 返回体结构

```java
/**
 * 统一 API 返回格式
 * @Data: Lombok注解，生成getter/setter方法
 * @NoArgsConstructor/@AllArgsConstructor: Lombok注解，生成构造函数
 * @JsonInclude(JsonInclude.Include.NON_NULL): Jackson注解，null值不序列化
 * @Schema: Swagger文档注解，描述响应体结构
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
@Schema(description = "统一响应体")
public class ApiResponse<T> implements Serializable {

    @Schema(description = "响应码", example = "SUCCESS")
    private String code;

    @Schema(description = "响应消息", example = "操作成功")
    private String message;

    @Schema(description = "响应数据")
    private T data;

    @Schema(description = "时间戳", example = "1719876543210")
    private Long timestamp;

    // 静态工厂方法
    public static <T> ApiResponse<T> success() {
        return new ApiResponse<>(
            ErrorCode.SUCCESS.getCode(),
            ErrorCode.SUCCESS.getDescription(),
            null,
            System.currentTimeMillis()
        );
    }

    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(
            ErrorCode.SUCCESS.getCode(),
            ErrorCode.SUCCESS.getDescription(),
            data,
            System.currentTimeMillis()
        );
    }

    public static <T> ApiResponse<T> error(ErrorCode errorCode) {
        return new ApiResponse<>(
            errorCode.getCode(),
            errorCode.getDescription(),
            null,
            System.currentTimeMillis()
        );
    }
}
```

#### 2. 错误码枚举 (ErrorCode)

```java
/**
 * 统一错误码枚举
 * @Getter: Lombok注解，生成getter方法
 * implements BaseEnum<String>: 实现基础枚举接口
 */
@Getter
public enum ErrorCode implements BaseEnum<String> {

    // 成功
    SUCCESS("SUCCESS", "操作成功"),

    // 客户端错误 4xx
    BAD_REQUEST("BAD_REQUEST", "请求参数错误"),
    UNAUTHORIZED("UNAUTHORIZED", "未认证或认证已过期"),
    FORBIDDEN("FORBIDDEN", "没有访问权限"),
    NOT_FOUND("NOT_FOUND", "请求的资源不存在"),
    VALIDATE_FAILED("VALIDATE_FAILED", "参数校验失败"),

    // 业务错误 5xx
    BUSINESS_ERROR("BUSINESS_ERROR", "业务处理失败"),
    INTERNAL_SERVER_ERROR("INTERNAL_SERVER_ERROR", "服务器内部错误"),

    // 用户相关错误
    USER_NOT_FOUND("USER_NOT_FOUND", "用户不存在"),
    USER_ALREADY_EXISTS("USER_ALREADY_EXISTS", "用户已存在"),
    USERNAME_OR_PASSWORD_ERROR("USERNAME_OR_PASSWORD_ERROR", "用户名或密码错误");

    private final String code;
    private final String description;

    ErrorCode(String code, String description) {
        this.code = code;
        this.description = description;
    }

    @Override
    public String getCode() {
        return code;
    }

    @Override
    public String getDescription() {
        return description;
    }
}
```

### 请求参数规范

#### 1. 请求对象定义

```java
/**
 * 认证相关请求对象
 * 使用内部静态类组织相关的请求对象
 */
public class AuthRequests {

    /**
     * 登录请求
     * @Data: Lombok注解
     * @Schema: Swagger文档注解，描述请求体
     */
    @Data
    @Schema(description = "登录请求")
    public static class LoginRequest {

        /**
         * @Schema: Swagger字段描述
         * @NotBlank: Bean Validation注解，不能为null且去除空白字符后长度大于0
         * @Size: Bean Validation注解，限制字符串长度
         */
        @Schema(description = "用户名", example = "admin")
        @NotBlank(message = "用户名不能为空")
        @Size(min = 3, max = 50, message = "用户名长度必须在3-50个字符之间")
        private String username;

        @Schema(description = "密码", example = "123456")
        @NotBlank(message = "密码不能为空")
        @Size(min = 6, max = 100, message = "密码长度必须在6-100个字符之间")
        private String password;
    }
}
```

**Bean Validation 注解说明**:
- `@NotBlank`: 字符串不能为null、空字符串或只包含空白字符
- `@NotNull`: 值不能为null
- `@Size`: 限制字符串、集合、数组的大小
- `@Min/@Max`: 限制数字的最小/最大值
- `@Email`: 验证邮箱格式
- `@Pattern`: 正则表达式验证

---

## 开发流程规范

### 新功能开发流程

#### 1. 实体类开发
```java
// 1. 继承BaseEntity
public class NewEntity extends BaseEntity {
    // 2. 添加业务字段
    // 3. 使用合适的MyBatis-Plus注解
}
```

#### 2. Mapper开发
```java
// 1. 继承BaseMapper获得基础CRUD
@Mapper
public interface NewEntityMapper extends BaseMapper<NewEntity> {
    // 2. 添加自定义查询方法
}
```

#### 3. Service开发
```java
// 1. 定义服务接口
public interface NewEntityService {
    // 定义业务方法
}

// 2. 实现服务类
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class NewEntityServiceImpl implements NewEntityService {
    // 实现业务逻辑
}
```

#### 4. Controller开发
```java
// 1. 添加必要注解
@RestController
@RequestMapping("/api/newentity")
@RequiredArgsConstructor
@Validated
public class NewEntityController {
    // 2. 实现REST接口
    // 3. 使用统一返回格式
}
```

## 代码提交规范

### 1. 提交信息格式
```
<type>: <subject>

<body>
```

### 2. 提交类型
- **feat**: 新功能
- **fix**: 修复bug
- **doc**: 文档更新
- **refactor**: 代码重构
- **test**: 测试相关

### 3. 提交示例
```
feat: 添加用户分页查询功能

实现用户列表分页查询API，支持按用户名、手机号模糊搜索；添加相关单元测试
```

---

## 异常处理规范

### 异常分类原则

#### 1. 预期异常（Checked Exceptions）
- **定义**: 业务逻辑中可预期的、正常的错误情况
- **处理方式**: 记录 WARN 日志，返回错误码，不记录堆栈信息
- **示例**: 参数校验失败、用户不存在、密码错误、权限不足

#### 2. 非预期异常（Unchecked Exceptions）
- **定义**: 程序运行时出现的技术故障
- **处理方式**: 记录 ERROR 日志，记录完整堆栈，返回 500 错误
- **示例**: 数据库连接失败、空指针异常、除零异常

### 业务异常类 (BusinessException)

```java
// ✅ 正确示例 1: 使用错误码
if (user == null) {
    throw new BusinessException(ErrorCode.USER_NOT_FOUND);
}

// ✅ 正确示例 2: 使用错误码 + 自定义消息
if (user == null) {
    throw new BusinessException(ErrorCode.USER_NOT_FOUND, "用户ID: " + userId + " 不存在");
}

// ✅ 正确示例 3: 使用自定义消息
if (balance < amount) {
    throw new BusinessException("余额不足，当前余额: " + balance);
}

// ❌ 错误示例: 不要用于系统异常
try {
    database.connect();
} catch (SQLException e) {
    // ❌ 错误：应该让异常向上抛出，由 GlobalExceptionHandler 统一处理
    throw new BusinessException("数据库连接失败");
}
```

### 全局异常处理器 (GlobalExceptionHandler)

支持的异常类型

| 异常类型 | HTTP状态码 | 日志级别 | 堆栈跟踪 | 说明 |
|---------|----------|---------|---------|------|
| `BusinessException` | 200 | WARN | 否 | 业务异常 |
| `MethodArgumentNotValidException` | 200 | WARN | 否 | @Valid 参数校验异常 |
| `BindException` | 200 | WARN | 否 | @Validated 参数绑定异常 |
| `ConstraintViolationException` | 200 | WARN | 否 | 约束违反异常 |
| `BadCredentialsException` | 200 | WARN | 否 | 认证失败异常 |
| `AccessDeniedException` | 200 | WARN | 否 | 权限不足异常 |
| `Exception` | 500 | ERROR | 是 | 所有未捕获的异常 |

### 异常处理最佳实践

#### 1. Controller 层

```java
@RestController
@RequestMapping("/api/user")
@RequiredArgsConstructor
public class UserController {
    
    private final UserService userService;
    
    /**
     * ✅ 正确示例：不捕获异常，让 GlobalExceptionHandler 统一处理
     */
    @GetMapping("/{id}")
    public ApiResponse<User> getById(@PathVariable Long id) {
        User user = userService.getById(id);
        return ApiResponse.success(user);
    }
    
    /**
     * ❌ 错误示例：不要在 Controller 中 try-catch
     */
    @GetMapping("/{id}/bad")
    public ApiResponse<User> getByIdBad(@PathVariable Long id) {
        try {
            User user = userService.getById(id);
            return ApiResponse.success(user);
        } catch (BusinessException e) {
            // ❌ 不要这样做，GlobalExceptionHandler 会自动处理
            return ApiResponse.error(e.getErrorCode(), e.getMessage());
        }
    }
}
```

#### 2. Service 层

```java
@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {
    
    private final UserMapper userMapper;
    
    /**
     * ✅ 正确示例：抛出业务异常
     */
    @Override
    public User getById(Long id) {
        User user = userMapper.selectById(id);
        if (user == null) {
            throw new BusinessException(ErrorCode.USER_NOT_FOUND);
        }
        return user;
    }
    
    /**
     * ✅ 正确示例：系统异常不捕获，向上抛出
     */
    @Override
    public void updateUser(User user) {
        // 如果数据库操作失败，会抛出 SQLException 等系统异常
        // 不要捕获，让 GlobalExceptionHandler 统一处理
        userMapper.updateById(user);
    }
    
    /**
     * ❌ 错误示例：不要返回 null
     */
    @Override
    public User getByIdBad(Long id) {
        User user = userMapper.selectById(id);
        // ❌ 不要返回 null，应该抛出异常
        return user;
    }
}
```

#### 3. 参数校验

```java
/**
 * ✅ 正确示例：使用 @Valid 注解自动校验
 */
@PostMapping
public ApiResponse<Void> create(@RequestBody @Valid UserCreateRequest request) {
    // 如果校验失败，会自动抛出 MethodArgumentNotValidException
    // GlobalExceptionHandler 会捕获并返回错误码
    userService.create(request);
    return ApiResponse.success();
}

// 请求对象定义
@Data
public class UserCreateRequest {
    
    @NotBlank(message = "用户名不能为空")
    @Size(min = 3, max = 20, message = "用户名长度必须在3-20之间")
    private String username;
    
    @NotBlank(message = "密码不能为空")
    @Size(min = 6, max = 20, message = "密码长度必须在6-20之间")
    private String password;
    
    @Email(message = "邮箱格式不正确")
    private String email;
}
```

---

## 📊 日志追踪规范

### MDC 链路追踪原理

MDC（Mapped Diagnostic Context）是 SLF4J 提供的日志上下文机制：
- 在请求开始时将 traceId 放入 MDC
- 当前线程的所有日志都会包含这个 traceId
- 在请求结束时清理 MDC，避免内存泄漏

### 日志使用规范

#### 1. 日志级别使用标准

| 级别 | 使用场景 | 示例 |
|-----|---------|------|
| **ERROR** | 系统错误、未捕获异常 | `log.error("系统异常", e)` |
| **WARN** | 业务异常、预期错误 | `log.warn("用户不存在: {}", userId)` |
| **INFO** | 重要业务流程、状态变更 | `log.info("用户登录成功: {}", username)` |
| **DEBUG** | 调试信息、详细流程 | `log.debug("查询参数: {}", params)` |
| **TRACE** | 非常详细的调试信息 | `log.trace("方法执行: {}", methodName)` |

#### 2. 日志输出最佳实践

```java
@Service
@RequiredArgsConstructor
@Slf4j  // Lombok 注解，自动生成 log 对象
public class UserServiceImpl implements UserService {
    
    /**
     * ✅ 正确示例：使用占位符
     */
    @Override
    public User login(String username, String password) {
        log.info("用户登录请求: username={}", username);  // ✅ 使用占位符
        
        User user = userMapper.selectByUsername(username);
        if (user == null) {
            log.warn("用户不存在: {}", username);  // ✅ WARN 级别
            throw new BusinessException(ErrorCode.USER_NOT_FOUND);
        }
        
        if (!passwordEncoder.matches(password, user.getPassword())) {
            log.warn("密码错误: username={}", username);  // ✅ 不记录密码
            throw new BusinessException(ErrorCode.USERNAME_OR_PASSWORD_ERROR);
        }
        
        log.info("用户登录成功: userId={}, username={}", user.getId(), username);
        return user;
    }
    
    /**
     * ❌ 错误示例：不要使用字符串拼接
     */
    @Override
    public User loginBad(String username, String password) {
        // ❌ 字符串拼接会消耗性能，即使日志级别不够也会执行拼接
        log.info("用户登录请求: username=" + username);
        
        // ❌ 不要记录敏感信息（密码、身份证号等）
        log.info("用户登录: username={}, password={}", username, password);
        
        return null;
    }
}
```

#### 3. 异常日志规范

```java
/**
 * ✅ 正确示例：记录完整异常堆栈
 */
try {
    riskyOperation();
} catch (Exception e) {
    // ✅ 记录完整堆栈信息
    log.error("操作失败: {}", e.getMessage(), e);
    throw e;
}

/**
 * ❌ 错误示例：只记录异常消息
 */
try {
    riskyOperation();
} catch (Exception e) {
    // ❌ 没有记录堆栈信息，无法定位问题
    log.error("操作失败: {}", e.getMessage());
    throw e;
}
```

### 日志文件结构

```
logs/
├── 2025-10-22-10-30-00.log        # 普通日志
├── 2025-10-22-10-30-00-error.log  # 错误日志
├── 2025-10-22-14-15-30.log        # 下次启动的日志
└── 2025-10-22-14-15-30-error.log  # 下次启动的错误日志
```

### 链路追踪使用场景

#### 1. 分布式追踪

```java
// 微服务间传递 traceId
RestTemplate restTemplate = new RestTemplate();
HttpHeaders headers = new HttpHeaders();
headers.set("X-Trace-Id", MDC.get("traceId"));

HttpEntity<String> entity = new HttpEntity<>(headers);
restTemplate.exchange(url, HttpMethod.GET, entity, String.class);
```

#### 2. 日志查询

```bash
# 根据 traceId 查询完整请求链路
grep "abc123def456" logs/2025-10-22-10-30-00.log
```

#### 3. 日志格式示例

```
[2025-10-22 10:30:15.123] [http-nio-8080-exec-1] [INFO ] [abc123def456] c.d.s.c.AuthController - 用户登录请求: username=admin
[2025-10-22 10:30:15.234] [http-nio-8080-exec-1] [DEBUG] [abc123def456] c.d.s.s.i.UserServiceImpl - 查询用户: username=admin
[2025-10-22 10:30:15.345] [http-nio-8080-exec-1] [INFO ] [abc123def456] c.d.s.s.i.AuthServiceImpl - 用户登录成功: userId=1001
[2025-10-22 10:30:15.456] [http-nio-8080-exec-1] [INFO ] [abc123def456] c.d.s.c.l.TraceIdFilter - 请求完成: POST /api/auth/login  - 耗时: 333ms
```

---

## 🔐 RBAC权限控制规范

### 权限注解使用规范

#### 1. 注解定义

```java
@RequirePermission(
        value = {"权限编码1", "权限编码2"},  // 所需权限列表
        logical = LogicType.OR              // 权限逻辑（AND/OR）
)
```

#### 2. 使用场景

**Controller方法级权限控制**：

```java
@RestController
@RequestMapping("/api/user")
public class UserController {
    
    // ✅ 正确示例：单个权限
    @RequirePermission("USER:VIEW")
    @GetMapping("/{id}")
    public ApiResponse<User> getById(@PathVariable Long id) {
        return ApiResponse.success(userService.getById(id));
    }
    
    // ✅ 正确示例：多个权限（OR逻辑）
    @RequirePermission(value = {"USER:UPDATE", "USER:CREATE"}, logical = LogicType.OR)
    @PostMapping
    public ApiResponse<Void> create(@RequestBody UserCreateRequest request) {
        userService.create(request);
        return ApiResponse.success();
    }
    
    // ✅ 正确示例：多个权限（AND逻辑）
    @RequirePermission(value = {"USER:DELETE", "SYSTEM:CONFIG"}, logical = LogicType.AND)
    @DeleteMapping("/{id}")
    public ApiResponse<Void> delete(@PathVariable Long id) {
        userService.delete(id);
        return ApiResponse.success();
    }
    
    // ✅ 正确示例：可重复注解（多个注解之间是 AND 关系）
    @RequirePermission("USER:VIEW")
    @RequirePermission(value = {"USER:CREATE", "USER:UPDATE"}, logical = LogicType.OR)
    @PostMapping("/example")
    public ApiResponse<Void> example() {
        // 需要：USER:VIEW AND (USER:CREATE OR USER:UPDATE)
        // 即必须拥有 USER:VIEW 权限，并且至少拥有 USER:CREATE 或 USER:UPDATE 之一
        return ApiResponse.success();
    }
}
```

**Controller类级别权限控制**：

```java
// ✅ 正确示例：类级别权限（所有方法都需要此权限）
@RestController
@RequestMapping("/api/permission")
@RequirePermission("PERMISSION:VIEW")
public class PermissionController {
    // 所有方法都需要 PERMISSION:VIEW 权限
}
```

#### 3. 权限编码规范

权限编码格式：`模块:操作`

- **模块**：大写字母和下划线，如 USER、ROLE、PERMISSION、SYSTEM
- **操作**：VIEW、CREATE、UPDATE、DELETE、EXPORT等
- **示例**：USER:CREATE、ROLE:UPDATE、SYSTEM:CONFIG

```java
// ✅ 正确示例
@RequirePermission("USER:CREATE")
@RequirePermission("ROLE:VIEW")
@RequirePermission("SYSTEM:CONFIG")

// ❌ 错误示例
@RequirePermission("user:create")      // 必须大写
@RequirePermission("USER-CREATE")      // 分隔符必须是冒号
@RequirePermission("CREATE_USER")      // 格式错误
```

### 权限检查最佳实践

#### 1. 权限缓存自动更新

**缓存机制**：权限信息存储在 Redis 的 UserPrincipal 对象中（与 Token 一起），当角色或权限发生变更时，系统会**自动更新** Redis
缓存。

**自动更新触发点**：

```java
// ✅ 用户角色服务（UserRoleServiceImpl）
@Override
@Transactional(rollbackFor = Exception.class)
public void assignRolesToUser(Long userId, List<Long> roleIds) {
    // 分配角色给用户
    for (Long roleId : roleIds) {
        // ... 分配逻辑
    }
    
    // ✅ 自动更新用户的角色和权限缓存
    permissionCheckService.updateUserRolesAndPermissions(userId);
}

@Override
@Transactional(rollbackFor = Exception.class)
public void removeUserRole(Long userId, Long roleId) {
    // 移除用户角色
    userRoleMapper.deleteByUserIdAndRoleId(userId, roleId);
    
    // ✅ 自动更新用户的角色和权限缓存
    permissionCheckService.updateUserRolesAndPermissions(userId);
}

// ✅ 角色权限服务（RolePermissionServiceImpl）
@Override
@Transactional(rollbackFor = Exception.class)
public void assignPermissionsToRole(Long roleId, List<Long> permissionIds) {
    // 分配权限给角色
    for (Long permissionId : permissionIds) {
        // ... 分配逻辑
    }
    
    // ✅ 自动更新拥有该角色的所有用户的权限缓存
    permissionCheckService.updateRoleUsersPermissions(roleId);
}

@Override
@Transactional(rollbackFor = Exception.class)
public void removeRolePermission(Long roleId, Long permissionId) {
    // 移除角色权限
    rolePermissionMapper.deleteByRoleIdAndPermissionId(roleId, permissionId);
    
    // ✅ 自动更新拥有该角色的所有用户的权限缓存
    permissionCheckService.updateRoleUsersPermissions(roleId);
}
```

#### 2. 异常处理

权限不足时会抛出 `BusinessException(ErrorCode.FORBIDDEN)`，由 `GlobalExceptionHandler` 统一处理：

```java
@ExceptionHandler(BusinessException.class)
public ApiResponse<Void> handleBusinessException(BusinessException e) {
    if (e.getErrorCode() == ErrorCode.FORBIDDEN) {
        log.warn("权限不足: {}", e.getMessage());
    }
    return ApiResponse.error(e.getErrorCode(), e.getMessage());
}
```

### 权限管理开发规范

#### 1. 新增权限

新增权限时需要：

1. 在数据库中添加权限记录
2. 分配给相应的角色
3. 在接口上添加 `@RequirePermission` 注解

```java
// 1. 添加权限记录到数据库
Permission permission = new Permission();
permission.setPermissionCode("USER:EXPORT");
permission.setPermissionName("导出用户");
permission.setDescription("导出用户数据");
permissionService.createPermission(permission);

// 2. 分配给角色（如：管理员）
List<Long> permissionIds = Arrays.asList(permission.getId());
rolePermissionService.assignPermissionsToRole(adminRoleId, permissionIds);

// 3. 在接口上添加权限注解
@RequirePermission("USER:EXPORT")
@GetMapping("/export")
public ApiResponse<Void> exportUsers() {
    // 导出用户数据
    return ApiResponse.success();
}
```

#### 2. 删除权限

删除权限时需要：

1. 检查权限是否正在使用（是否有角色拥有该权限）
2. 删除角色权限关联
3. 删除权限记录
4. 清除相关缓存

```java
@Override
@Transactional(rollbackFor = Exception.class)
public void deletePermission(Long id) {
    // 1. 检查权限是否存在
    Permission permission = getById(id);
    
    // 2. 检查权限是否正在使用
    List<RolePermission> rolePermissions = rolePermissionMapper.selectByPermissionId(id);
    if (!rolePermissions.isEmpty()) {
        throw new BusinessException(ErrorCode.PERMISSION_IN_USE);
    }
    
    // 3. 删除权限（逻辑删除）
    permissionMapper.deleteById(id);
    log.info("删除权限成功: id={}, permissionCode={}", id, permission.getPermissionCode());
}
```

#### 3. 修改权限

修改权限时需要：

1. 更新权限信息
2. 清除相关缓存

```java
@Override
@Transactional(rollbackFor = Exception.class)
public void updatePermission(Long id, Permission permission) {
    // 1. 更新权限
    permission.setId(id);
    permissionMapper.updateById(permission);
    
    // 2. 清除拥有该权限的所有角色的用户缓存
    List<Role> roles = rolePermissionService.getRolesByPermissionId(id);
    for (Role role : roles) {
        permissionCheckService.clearRoleUsersPermissionCache(role.getId());
    }
    
    log.info("更新权限成功: id={}, permissionCode={}", id, permission.getPermissionCode());
}
```

### Service层实现规范

#### 1. RoleService示例

```java
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
@Slf4j
public class RoleServiceImpl implements RoleService {
    
    private final RoleMapper roleMapper;
    private final UserRoleMapper userRoleMapper;
    
    @Override
    public Role getById(Long id) {
        Role role = roleMapper.selectById(id);
        if (role == null) {
            log.warn("角色不存在: id={}", id);
            throw new BusinessException(ErrorCode.ROLE_NOT_FOUND);
        }
        return role;
    }
    
    @Override
    @Transactional(rollbackFor = Exception.class)
    public void createRole(Role role) {
        // 1. 检查角色编码是否已存在
        Role existingRole = roleMapper.selectByRoleCode(role.getRoleName());
        if (existingRole != null) {
            log.warn("角色编码已存在: roleCode={}", role.getRoleName());
            throw new BusinessException(ErrorCode.ROLE_CODE_ALREADY_EXISTS);
        }
        
        // 2. 创建角色
        roleMapper.insert(role);
        log.info("创建角色成功: id={}, roleCode={}", role.getId(), role.getRoleName());
    }
    
    @Override
    @Transactional(rollbackFor = Exception.class)
    public void deleteRole(Long id) {
        // 1. 检查角色是否存在
        Role role = getById(id);
        
        // 2. 检查角色是否正在使用
        List<UserRole> userRoles = userRoleMapper.selectByRoleId(id);
        if (!userRoles.isEmpty()) {
            log.warn("角色正在使用中，无法删除: id={}, roleCode={}, userCount={}", 
                id, role.getRoleName(), userRoles.size());
            throw new BusinessException(ErrorCode.ROLE_IN_USE);
        }
        
        // 3. 删除角色（逻辑删除）
        roleMapper.deleteById(id);
        log.info("删除角色成功: id={}, roleCode={}", id, role.getRoleName());
    }
}
```

#### 2. 事务和日志规范

```java
// ✅ 正确示例：类级别只读事务，写操作方法单独标注事务
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)  // 类级别：默认只读事务
@Slf4j
public class PermissionServiceImpl implements PermissionService {
    
    @Override
    public Permission getById(Long id) {
        // 查询方法，使用类级别的只读事务
        Permission permission = permissionMapper.selectById(id);
        if (permission == null) {
            log.warn("权限不存在: id={}", id);  // ✅ 使用 WARN 级别
            throw new BusinessException(ErrorCode.PERMISSION_NOT_FOUND);
        }
        return permission;
    }
    
    @Override
    @Transactional(rollbackFor = Exception.class)  // 写操作：覆盖为可写事务
    public void createPermission(Permission permission) {
        // 创建权限
        permissionMapper.insert(permission);
        log.info("创建权限成功: id={}, permissionCode={}", 
            permission.getId(), permission.getPermissionCode());  // ✅ 使用 INFO 级别
    }
}
```

#### 3. 参数校验规范

```java
// ✅ 正确示例：在Service层进行业务校验
@Override
@Transactional(rollbackFor = Exception.class)
public void assignRolesToUser(Long userId, List<Long> roleIds) {
    // 1. 校验用户是否存在
    User user = userMapper.selectById(userId);
    if (user == null) {
        log.warn("用户不存在: userId={}", userId);
        throw new BusinessException(ErrorCode.USER_NOT_FOUND);
    }
    
    // 2. 批量分配角色
    for (Long roleId : roleIds) {
        // 校验角色是否存在
        Role role = roleMapper.selectById(roleId);
        if (role == null) {
            log.warn("角色不存在: roleId={}", roleId);
            throw new BusinessException(ErrorCode.ROLE_NOT_FOUND);
        }
        
        // 校验是否已经分配
        UserRole existingUserRole = userRoleMapper.selectByUserIdAndRoleId(userId, roleId);
        if (existingUserRole != null) {
            log.warn("用户已拥有该角色: userId={}, roleId={}", userId, roleId);
            throw new BusinessException(ErrorCode.USER_ROLE_ALREADY_EXISTS);
        }
        
        // 创建关联
        UserRole userRole = new UserRole();
        userRole.setUserId(userId);
        userRole.setRoleId(roleId);
        userRoleMapper.insert(userRole);
        log.info("分配角色给用户成功: userId={}, roleId={}", userId, roleId);
    }
}
```

---

## 📝 总结

本规范覆盖了Spring Boot应用开发的各个方面，从代码编写到权限控制，从异常处理到日志追踪。遵循这些规范可以：

1. **提升代码质量**：统一的编码风格，易于维护
2. **提高开发效率**：标准化的开发流程，减少沟通成本
3. **保障系统安全**：完善的权限控制，规范的异常处理
4. **便于问题定位**：完整的日志记录，清晰的链路追踪

建议在实际开发中严格遵循本规范，并根据项目实际情况进行适当调整。
